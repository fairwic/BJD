# BJDå›¢è´­å¹³å° - åç«¯å¼€å‘æŒ‡å—ï¼ˆP0æ ¸å¿ƒåŠŸèƒ½ï¼‰

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **é¡¹ç›®åç§°**ï¼šGOMaster / æ‹¼å›¢å¤§å¸ˆ
- **ç‰ˆæœ¬å·**ï¼šv1.1.0
- **åˆ›å»ºæ—¥æœŸ**ï¼š2024-12-08
- **æ–‡æ¡£ç±»å‹**ï¼šåç«¯å¼€å‘æŒ‡å—
- **ä¼˜å…ˆçº§**ï¼šP0ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼Œä¼˜å…ˆå®ç°ï¼‰
- **æŠ€æœ¯æ ˆ**ï¼šRust + Axum + PostgreSQL + sqlx

---

## ğŸ“‘ ç›®å½•

- [ä¸€ã€P0åŠŸèƒ½æ¦‚è§ˆ](#ä¸€p0åŠŸèƒ½æ¦‚è§ˆ)
- [äºŒã€APIæ¥å£æ¸…å•](#äºŒapiæ¥å£æ¸…å•)
- [ä¸‰ã€ä¸šåŠ¡æµç¨‹å›¾](#ä¸‰ä¸šåŠ¡æµç¨‹å›¾)
- [å››ã€æ•°æ®åº“è¡¨ç»“æ„](#å››æ•°æ®åº“è¡¨ç»“æ„)
- [äº”ã€æ ¸å¿ƒä¸šåŠ¡é€»è¾‘](#äº”æ ¸å¿ƒä¸šåŠ¡é€»è¾‘)
- [å…­ã€æŠ€æœ¯è¦ç‚¹](#å…­æŠ€æœ¯è¦ç‚¹)
- [ä¸ƒã€å¼€å‘è®¡åˆ’](#ä¸ƒå¼€å‘è®¡åˆ’)

---

## ä¸€ã€P0åŠŸèƒ½æ¦‚è§ˆ

### 1.1 åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½æ¨¡å— | ä¼˜å…ˆçº§ | å‰ç«¯çŠ¶æ€ | åç«¯çŠ¶æ€ | æ¥å£æ•°é‡ | æ•°æ®è¡¨æ•°é‡ |
|---------|--------|---------|---------|---------|-----------|
| å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç† | **P0** | âœ… å®Œæˆ | â³ å¾…å¼€å‘ | 7ä¸ª | 2ä¸ª |
| æˆå°±ç³»ç»Ÿ | **P0** | âœ… å®Œæˆ | â³ å¾…å¼€å‘ | 3ä¸ª | 2ä¸ª |
| BJDçŸ¥è¯†åº“ | **P0** | âœ… å®Œæˆ | â³ å¾…å¼€å‘ | 5ä¸ª | 3ä¸ª |
| è®¢é‡‘æ‰˜ç®¡ | **P0** | â³ å¾…å¼€å‘ | â³ å¾…å¼€å‘ | 3ä¸ª | 1ä¸ª |
| å›¢é•¿ä¿è¯é‡‘ | **P0** | â³ å¾…å¼€å‘ | â³ å¾…å¼€å‘ | 3ä¸ª | 2ä¸ª |
| è‡ªåŠ¨å‚¬æ¬¾ | **P0** | â³ å¾…å¼€å‘ | â³ å¾…å¼€å‘ | 2ä¸ª | 1ä¸ª |
| é»‘åå•ç®¡ç† | **P0** | â³ å¾…å¼€å‘ | â³ å¾…å¼€å‘ | 3ä¸ª | 1ä¸ª |

**æ€»è®¡**ï¼š**26ä¸ªAPIæ¥å£**ï¼Œ**12ä¸ªæ•°æ®è¡¨**

---

### 1.2 ä¾èµ–å…³ç³»

```mermaid
graph TD
    A[å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç†] --> B[è®¢å•ç³»ç»Ÿ]
    A --> C[åˆåŒç³»ç»Ÿ]
    
    D[æˆå°±ç³»ç»Ÿ] --> E[è®¢å•ç³»ç»Ÿ]
    D --> F[ç”¨æˆ·ç³»ç»Ÿ]
    D --> G[ç¤¾äº¤ç³»ç»Ÿ]
    
    H[è®¢é‡‘æ‰˜ç®¡] --> B
    H --> I[æ”¯ä»˜ç³»ç»Ÿ]
    
    J[å›¢é•¿ä¿è¯é‡‘] --> K[ç”¨æˆ·è®¤è¯]
    J --> E
    
    L[è‡ªåŠ¨å‚¬æ¬¾] --> B
    L --> M[é€šçŸ¥ç³»ç»Ÿ]
    L --> N[é»‘åå•ç®¡ç†]
    
    N --> E
    
    style A fill:#e1f5ff
    style D fill:#e1f5ff
    style H fill:#ffe1e1
    style J fill:#ffe1e1
    style L fill:#fff4e1
    style N fill:#fff4e1
```

---

## äºŒã€APIæ¥å£æ¸…å•

### 2.1 å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç†ï¼ˆ7ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/dolls` | è·å–å¨ƒå¨ƒåˆ—è¡¨ | ç™»å½•ç”¨æˆ· |
| GET | `/api/v1/dolls/{dollId}` | è·å–å¨ƒå¨ƒè¯¦æƒ… | å¨ƒå¨ƒæ‰€æœ‰è€… |
| POST | `/api/v1/dolls` | æ·»åŠ å¨ƒå¨ƒ | ç™»å½•ç”¨æˆ· |
| PUT | `/api/v1/dolls/{dollId}` | æ›´æ–°å¨ƒå¨ƒä¿¡æ¯ | å¨ƒå¨ƒæ‰€æœ‰è€… |
| DELETE | `/api/v1/dolls/{dollId}` | åˆ é™¤å¨ƒå¨ƒ | å¨ƒå¨ƒæ‰€æœ‰è€… |
| POST | `/api/v1/dolls/{dollId}/maintenance` | æ·»åŠ ä¿å…»è®°å½• | å¨ƒå¨ƒæ‰€æœ‰è€… |
| POST | `/api/v1/dolls/{dollId}/id-card` | ç”Ÿæˆç”µå­èº«ä»½è¯ | å¨ƒå¨ƒæ‰€æœ‰è€… |

#### ä¸šåŠ¡è§„åˆ™
- âœ… ç”¨æˆ·åªèƒ½æŸ¥çœ‹/ä¿®æ”¹è‡ªå·±çš„å¨ƒå¨ƒ
- âœ… åˆ é™¤å¨ƒå¨ƒæ—¶çº§è”åˆ é™¤ä¿å…»è®°å½•
- âœ… å…»å¨ƒå¤©æ•° = å½“å‰æ—¥æœŸ - birthday
- âœ… æ”¯æŒä»è®¢å•å¯¼å…¥å¨ƒå¨ƒä¿¡æ¯

---

### 2.2 æˆå°±ç³»ç»Ÿï¼ˆ3ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/achievements` | è·å–æˆå°±åˆ—è¡¨ | ç™»å½•ç”¨æˆ· |
| POST | `/api/v1/achievements/check` | æ£€æŸ¥æˆå°±è§£é” | ç³»ç»Ÿå†…éƒ¨ |
| POST | `/api/v1/achievements/{achievementId}/claim` | é¢†å–æˆå°±å¥–åŠ± | ç™»å½•ç”¨æˆ· |

#### ä¸šåŠ¡è§„åˆ™
- âœ… æˆå°±è‡ªåŠ¨è§£é”ï¼ˆäº‹ä»¶è§¦å‘ï¼‰
- âœ… å¥–åŠ±åŒ…æ‹¬ï¼šè™šæ‹Ÿå¾½ç«  + ä¼˜æƒ åˆ¸ + ä¿¡ç”¨åˆ†
- âœ… æˆå°±ç¨€æœ‰åº¦ï¼š1-æ™®é€šã€2-ç¨€æœ‰ã€3-å²è¯—
- âœ… å·²è§£é”æˆå°±å¯åˆ†äº«

---

### 2.3 BJDçŸ¥è¯†åº“ï¼ˆ5ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/knowledge/articles` | è·å–æ–‡ç« åˆ—è¡¨ | å…¬å¼€ |
| GET | `/api/v1/knowledge/articles/{articleId}` | è·å–æ–‡ç« è¯¦æƒ… | å…¬å¼€ |
| GET | `/api/v1/knowledge/questions` | è·å–çƒ­é—¨é—®ç­” | å…¬å¼€ |
| GET | `/api/v1/knowledge/search` | æœç´¢çŸ¥è¯†åº“ | å…¬å¼€ |
| POST | `/api/v1/knowledge/{type}/{id}/like` | ç‚¹èµæ–‡ç« /å›ç­” | ç™»å½•ç”¨æˆ· |

#### ä¸šåŠ¡è§„åˆ™
- âœ… æ”¯æŒå…¨æ–‡æœç´¢ï¼ˆMySQL FULLTEXTï¼‰
- âœ… é˜…è¯»æ•°è‡ªåŠ¨+1ï¼ˆè®¿é—®è¯¦æƒ…é¡µæ—¶ï¼‰
- âœ… æ–‡ç« æ”¯æŒMarkdownæ ¼å¼
- âœ… è§†é¢‘ç±»å‹æ–‡ç« éœ€è¦è§†é¢‘URL

---

### 2.4 è®¢é‡‘æ‰˜ç®¡ï¼ˆ3ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| POST | `/api/v1/orders/{orderId}/deposit-escrow` | æ”¯ä»˜è®¢é‡‘ï¼ˆæ‰˜ç®¡ï¼‰ | è®¢å•æ‰€æœ‰è€… |
| GET | `/api/v1/orders/{orderId}/escrow-status` | æŸ¥è¯¢æ‰˜ç®¡çŠ¶æ€ | è®¢å•ç›¸å…³æ–¹ |
| POST | `/api/v1/orders/{orderId}/refund` | ç”³è¯·é€€æ¬¾ | è®¢å•æ‰€æœ‰è€… |

#### ä¸šåŠ¡è§„åˆ™
- âœ… è®¢é‡‘å…ˆæ‰˜ç®¡åœ¨å¹³å°ï¼Œä¸ç›´æ¥ç»™å›¢é•¿
- âœ… æˆªå›¢æˆåŠŸ â†’ è‡ªåŠ¨ç»“ç®—ç»™å›¢é•¿
- âœ… æµå›¢å¤±è´¥ â†’ 72å°æ—¶å†…è‡ªåŠ¨é€€æ¬¾
- âœ… è¶…æœŸæœªæˆªå›¢ â†’ è‡ªåŠ¨é€€æ¬¾

---

### 2.5 å›¢é•¿ä¿è¯é‡‘ï¼ˆ3ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/deposits/leader/{leaderId}` | è·å–ä¿è¯é‡‘ä¿¡æ¯ | å›¢é•¿æœ¬äºº |
| POST | `/api/v1/deposits/pay` | ç¼´çº³ä¿è¯é‡‘ | å›¢é•¿ |
| POST | `/api/v1/deposits/withdraw-interest` | æå–åˆ©æ¯ | å›¢é•¿æœ¬äºº |

#### ä¸šåŠ¡è§„åˆ™
- âœ… é¦–æ¬¡å¼€å›¢éœ€ç¼´çº³5000å…ƒä¿è¯é‡‘
- âœ… ä¿¡ç”¨åˆ†â‰¥90å¯é™è‡³3000å…ƒ
- âœ… ä¿è¯é‡‘å¹´åŒ–3%ç”Ÿæ¯
- âœ… ç”¨äºèµ”ä»˜è·‘å•ã€è´¨é‡é—®é¢˜

---

### 2.6 è‡ªåŠ¨å‚¬æ¬¾ï¼ˆ2ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/orders/{orderId}/reminders` | è·å–å‚¬æ¬¾è®°å½• | å›¢é•¿/è®¢å•æ‰€æœ‰è€… |
| POST | `/api/v1/orders/{orderId}/send-reminder` | æ‰‹åŠ¨è§¦å‘å‚¬æ¬¾ | å›¢é•¿ |

#### ä¸šåŠ¡è§„åˆ™
- âœ… è‡ªåŠ¨å‚¬æ¬¾ï¼šç¬¬3/7/15/25å¤©
- âœ… å¤šæ¸ é“ï¼šçŸ­ä¿¡ + å¾®ä¿¡ + Appæ¨é€
- âœ… è¶…30å¤©è‡ªåŠ¨åŠ å…¥é»‘åå•
- âœ… è¡¥æ¬¾åè‡ªåŠ¨è§£é™¤é¢„è­¦

---

### 2.7 é»‘åå•ç®¡ç†ï¼ˆ3ä¸ªæ¥å£ï¼‰â­

#### æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | æƒé™ |
|------|------|------|------|
| GET | `/api/v1/blacklist` | æŸ¥è¯¢é»‘åå• | å›¢é•¿ |
| POST | `/api/v1/blacklist` | æ·»åŠ åˆ°é»‘åå• | ç³»ç»Ÿ/å›¢é•¿ |
| DELETE | `/api/v1/blacklist/{userId}` | è§£é™¤é»‘åå• | ç³»ç»Ÿ |

#### ä¸šåŠ¡è§„åˆ™
- âœ… è·‘å•ç”¨æˆ·å…¨å¹³å°å…±äº«
- âœ… é»‘åå•ç”¨æˆ·æ— æ³•å‚å›¢
- âœ… è¡¥é½æ¬ æ¬¾è‡ªåŠ¨è§£é™¤
- âœ… å›¢é•¿å¯æŸ¥çœ‹ä½†ä¸èƒ½ç§è‡ªåˆ é™¤

---

## ä¸‰ã€ä¸šåŠ¡æµç¨‹å›¾

### 3.1 å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç†æµç¨‹

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant F as å‰ç«¯
    participant B as åç«¯
    participant DB as æ•°æ®åº“
    participant OSS as å¯¹è±¡å­˜å‚¨

    U->>F: 1. æ·»åŠ å¨ƒå¨ƒ
    F->>F: ä¸Šä¼ ç…§ç‰‡
    F->>OSS: 2. ä¸Šä¼ å›¾ç‰‡
    OSS-->>F: 3. è¿”å›å›¾ç‰‡URL
    F->>B: 4. POST /dolls (åŒ…å«å›¾ç‰‡URL)
    B->>B: éªŒè¯ç”¨æˆ·æƒé™
    B->>B: éªŒè¯æ•°æ®å®Œæ•´æ€§
    B->>DB: 5. æ’å…¥å¨ƒå¨ƒè®°å½•
    DB-->>B: 6. è¿”å›å¨ƒå¨ƒID
    B->>DB: 7. æŸ¥è¯¢å…³è”è®¢å•ä¿¡æ¯
    DB-->>B: 8. è¿”å›è®¢å•æ•°æ®
    B-->>F: 9. è¿”å›å®Œæ•´å¨ƒå¨ƒä¿¡æ¯
    F-->>U: 10. æ˜¾ç¤ºæˆåŠŸæç¤º

    Note over U,OSS: æŸ¥çœ‹å¨ƒå¨ƒè¯¦æƒ…
    U->>F: 11. æŸ¥çœ‹å¨ƒå¨ƒæ¡£æ¡ˆ
    F->>B: 12. GET /dolls/{dollId}
    B->>DB: 13. æŸ¥è¯¢å¨ƒå¨ƒ+ä¿å…»è®°å½•
    DB-->>B: 14. è¿”å›å®Œæ•´æ•°æ®
    B->>B: 15. è®¡ç®—å…»å¨ƒå¤©æ•°
    B-->>F: 16. è¿”å›å¨ƒå¨ƒè¯¦æƒ…
    F-->>U: 17. å±•ç¤ºå¨ƒå¨ƒæ¡£æ¡ˆ
```

---

### 3.2 æˆå°±ç³»ç»Ÿè§¦å‘æµç¨‹

```mermaid
flowchart TD
    Start([ç”¨æˆ·æ“ä½œ]) --> Event{äº‹ä»¶ç±»å‹}
    
    Event -->|å®Œæˆè®¢å•| E1[order_complete]
    Event -->|å®åè®¤è¯| E2[real_name_verify]
    Event -->|å‘å¸ƒåŠ¨æ€| E3[post_create]
    Event -->|æ”¶åˆ°ç‚¹èµ| E4[receive_like]
    
    E1 --> Check1[æ£€æŸ¥æˆå°±]
    E2 --> Check1
    E3 --> Check1
    E4 --> Check1
    
    Check1 --> Query[æŸ¥è¯¢ç”¨æˆ·æˆå°±è¿›åº¦]
    Query --> Update[æ›´æ–°è¿›åº¦]
    Update --> Compare{è¾¾åˆ°è¦æ±‚?}
    
    Compare -->|æ˜¯| Unlock[è§£é”æˆå°±]
    Compare -->|å¦| End1([ç»“æŸ])
    
    Unlock --> Reward{å‘æ”¾å¥–åŠ±}
    Reward -->|å¾½ç« | Badge[æ·»åŠ å¾½ç« ]
    Reward -->|ä¼˜æƒ åˆ¸| Coupon[ç”Ÿæˆä¼˜æƒ åˆ¸]
    Reward -->|ä¿¡ç”¨åˆ†| Credit[å¢åŠ ä¿¡ç”¨åˆ†]
    
    Badge --> Notify[æ¨é€é€šçŸ¥]
    Coupon --> Notify
    Credit --> Notify
    
    Notify --> End2([ç»“æŸ])
    
    style Unlock fill:#90EE90
    style Reward fill:#FFD700
    style Notify fill:#87CEEB
```

---

### 3.3 è®¢é‡‘æ‰˜ç®¡ä¸šåŠ¡æµç¨‹

```mermaid
stateDiagram-v2
    [*] --> å¾…ä»˜å®šé‡‘
    
    å¾…ä»˜å®šé‡‘ --> æ‰˜ç®¡ä¸­: ç”¨æˆ·æ”¯ä»˜å®šé‡‘
    
    æ‰˜ç®¡ä¸­ --> å·²ç»“ç®—: æˆªå›¢æˆåŠŸ<br/>(è‡ªåŠ¨ç»“ç®—ç»™å›¢é•¿)
    æ‰˜ç®¡ä¸­ --> å·²é€€æ¬¾: æµå›¢å¤±è´¥<br/>(72å°æ—¶å†…é€€æ¬¾)
    æ‰˜ç®¡ä¸­ --> å·²é€€æ¬¾: è¶…æœŸæœªæˆªå›¢<br/>(è‡ªåŠ¨é€€æ¬¾)
    
    å·²ç»“ç®— --> å›¢é•¿è´¦æˆ·: èµ„é‡‘åˆ°è´¦
    å·²é€€æ¬¾ --> ç”¨æˆ·è´¦æˆ·: é€€æ¬¾åˆ°è´¦
    
    å›¢é•¿è´¦æˆ· --> [*]
    ç”¨æˆ·è´¦æˆ· --> [*]
    
    note right of æ‰˜ç®¡ä¸­
        å®šæ—¶ä»»åŠ¡æ¯æ—¥æ£€æŸ¥ï¼š
        - æ˜¯å¦æˆªå›¢
        - æ˜¯å¦è¶…æœŸ
        - æ˜¯å¦æµå›¢
    end note
    
    note right of å·²ç»“ç®—
        ç»“ç®—æ¡ä»¶ï¼š
        - å›¢è´­æˆªå›¢æˆåŠŸ
        - çŠ¶æ€æ”¹ä¸º"åˆ¶ä½œä¸­"
    end note
```

---

### 3.4 è‡ªåŠ¨å‚¬æ¬¾æµç¨‹

```mermaid
flowchart TD
    Start([è®¢å•å®Œå·¥]) --> Notify[é€šçŸ¥è¡¥æ¬¾]
    Notify --> Day0[è®°å½•é€šçŸ¥æ—¶é—´]
    
    Day0 --> Cron[å®šæ—¶ä»»åŠ¡<br/>æ¯æ—¥9:00æ£€æŸ¥]
    
    Cron --> Check{æ£€æŸ¥å¤©æ•°}
    
    Check -->|Day 3| R1[ä¸€æ¬¡æé†’<br/>çŸ­ä¿¡]
    Check -->|Day 7| R2[äºŒæ¬¡æé†’<br/>çŸ­ä¿¡+å¾®ä¿¡]
    Check -->|Day 15| R3[ä¸‰æ¬¡æé†’<br/>çŸ­ä¿¡+å¾®ä¿¡+æ¨é€]
    Check -->|Day 25| R4[æœ€åè­¦å‘Š<br/>å…¨æ¸ é“+æ ‡è®°]
    Check -->|Day 30| R5[åŠ å…¥é»‘åå•]
    Check -->|å…¶ä»–| Wait[ç­‰å¾…]
    
    R1 --> Record1[è®°å½•æé†’]
    R2 --> Record1
    R3 --> Record1
    R4 --> Record1
    
    Record1 --> Wait
    Wait --> Next[ä¸‹æ¬¡æ£€æŸ¥]
    Next --> Cron
    
    R5 --> Black[æ·»åŠ åˆ°é»‘åå•è¡¨]
    Black --> Freeze[å†»ç»“å‚å›¢æƒé™]
    Freeze --> End([ç»“æŸ])
    
    Check -->|å·²æ”¯ä»˜| Paid[æ¸…é™¤å‚¬æ¬¾]
    Paid --> End
    
    style R5 fill:#FF6B6B
    style Black fill:#FF6B6B
    style Freeze fill:#FF6B6B
    style Paid fill:#90EE90
```

---

### 3.5 å›¢é•¿ä¿è¯é‡‘èµ”ä»˜æµç¨‹

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant S as ç³»ç»Ÿ
    participant L as å›¢é•¿
    participant D as ä¿è¯é‡‘è´¦æˆ·
    participant CS as å®¢æœ

    U->>S: 1. æŠ•è¯‰è´¨é‡é—®é¢˜/å»¶æœŸ
    S->>CS: 2. å·¥å•åˆ†é…
    CS->>CS: 3. å®¡æ ¸è¯æ®
    
    alt æŠ•è¯‰æˆç«‹
        CS->>S: 4. ç¡®è®¤èµ”ä»˜
        S->>D: 5. æ‰£é™¤ä¿è¯é‡‘
        D->>U: 6. èµ”ä»˜é‡‘é¢åˆ°è´¦
        S->>L: 7. é€šçŸ¥èµ”ä»˜è®°å½•
        
        alt ä¿è¯é‡‘ä¸è¶³
            S->>L: 8. é€šçŸ¥è¡¥ç¼´
            L->>D: 9. è¡¥å……ä¿è¯é‡‘
        end
        
        S->>S: 10. è®°å½•èµ”ä»˜å†å²
        S->>S: 11. é™ä½ä¿¡ç”¨åˆ†
    else æŠ•è¯‰ä¸æˆç«‹
        CS->>U: é©³å›æŠ•è¯‰
    end
```

---

## å››ã€æ•°æ®åº“è¡¨ç»“æ„

> **æ³¨æ„**ï¼šä»¥ä¸‹æ‰€æœ‰SQLè¯­å¥ä½¿ç”¨ **PostgreSQL 14+** è¯­æ³•ã€‚
> 
> ä¸MySQLçš„ä¸»è¦å·®å¼‚ï¼š
> - `AUTO_INCREMENT` â†’ `SERIAL` æˆ– `GENERATED ALWAYS AS IDENTITY`
> - `ENUM` â†’ `CREATE TYPE` æˆ–ä½¿ç”¨ `VARCHAR` + `CHECK` çº¦æŸ
> - `COMMENT` è¯­æ³•æ”¹ä¸º `COMMENT ON` è¯­å¥
> - `ON UPDATE CURRENT_TIMESTAMP` éœ€è¦ä½¿ç”¨è§¦å‘å™¨å®ç°
> - `ENGINE=InnoDB` å’Œ `CHARSET` ä¸éœ€è¦

### 4.1 å¨ƒå¨ƒæ¡£æ¡ˆç›¸å…³ï¼ˆ2å¼ è¡¨ï¼‰

#### dolls - å¨ƒå¨ƒæ¡£æ¡ˆè¡¨

```sql
-- PostgreSQLè¯­æ³•
CREATE TABLE dolls (
  id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  brand VARCHAR(100),
  size VARCHAR(20),
  skin_color VARCHAR(50),
  birthday DATE,
  weight INTEGER,
  height INTEGER,
  eye_color VARCHAR(50),
  wig_color VARCHAR(50),
  makeup VARCHAR(100),
  main_image VARCHAR(255),
  images JSONB,
  order_id VARCHAR(50),
  contract_id VARCHAR(50),
  outfit_count INTEGER DEFAULT 0,
  photo_count INTEGER DEFAULT 0,
  notes TEXT,
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (order_id) REFERENCES orders(id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_dolls_user ON dolls(user_id);
CREATE INDEX idx_dolls_birthday ON dolls(birthday);
CREATE INDEX idx_dolls_create_time ON dolls(create_time);

-- æ·»åŠ æ³¨é‡Š
COMMENT ON TABLE dolls IS 'å¨ƒå¨ƒæ¡£æ¡ˆè¡¨';
COMMENT ON COLUMN dolls.id IS 'å¨ƒå¨ƒID';
COMMENT ON COLUMN dolls.user_id IS 'ç”¨æˆ·ID';
COMMENT ON COLUMN dolls.name IS 'å¨ƒå¨ƒåç§°';
COMMENT ON COLUMN dolls.birthday IS 'ç”Ÿæ—¥';
COMMENT ON COLUMN dolls.images IS 'ç…§ç‰‡é›†åˆ(JSONæ•°ç»„)';

-- åˆ›å»ºè§¦å‘å™¨å®ç°è‡ªåŠ¨æ›´æ–°update_time
CREATE OR REPLACE FUNCTION update_dolls_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.update_time = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_dolls_updated_at
    BEFORE UPDATE ON dolls
    FOR EACH ROW
    EXECUTE FUNCTION update_dolls_updated_at();
```

#### maintenance_records - ä¿å…»è®°å½•è¡¨

```sql
CREATE TABLE maintenance_records (
  id VARCHAR(50) PRIMARY KEY COMMENT 'è®°å½•ID',
  doll_id VARCHAR(50) NOT NULL COMMENT 'å¨ƒå¨ƒID',
  date DATE NOT NULL COMMENT 'ä¿å…»æ—¥æœŸ',
  type VARCHAR(50) NOT NULL COMMENT 'ç±»å‹(æ¸…æ´ä¿å…»/ç»´ä¿®/å…¶ä»–)',
  note TEXT COMMENT 'å¤‡æ³¨è¯´æ˜',
  images JSON COMMENT 'ç…§ç‰‡',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  
  FOREIGN KEY (doll_id) REFERENCES dolls(id) ON DELETE CASCADE,
  
  INDEX idx_doll (doll_id),
  INDEX idx_date (date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='å¨ƒå¨ƒä¿å…»è®°å½•è¡¨';
```

---

### 4.2 æˆå°±ç³»ç»Ÿç›¸å…³ï¼ˆ2å¼ è¡¨ï¼‰

#### achievements - æˆå°±è¡¨

```sql
-- PostgreSQLè¯­æ³•
CREATE TABLE achievements (
  id VARCHAR(50) PRIMARY KEY,
  category VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  description VARCHAR(255),
  icon VARCHAR(10),
  required INTEGER DEFAULT 1,
  rarity INTEGER DEFAULT 1 CHECK (rarity >= 1 AND rarity <= 3),
  reward_badge BOOLEAN DEFAULT FALSE,
  reward_coupon INTEGER DEFAULT 0,
  reward_credit INTEGER DEFAULT 0,
  total_unlocked INTEGER DEFAULT 0,
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_achievements_category ON achievements(category);
CREATE INDEX idx_achievements_rarity ON achievements(rarity);

-- æ·»åŠ æ³¨é‡Š
COMMENT ON TABLE achievements IS 'æˆå°±è¡¨';
COMMENT ON COLUMN achievements.id IS 'æˆå°±ID';
COMMENT ON COLUMN achievements.category IS 'åˆ†ç±»(æ–°æ‰‹/è´­ç‰©/ç¤¾äº¤)';
COMMENT ON COLUMN achievements.rarity IS 'ç¨€æœ‰åº¦(1-æ™®é€š/2-ç¨€æœ‰/3-å²è¯—)';
```

#### user_achievements - ç”¨æˆ·æˆå°±è¡¨

```sql
CREATE TABLE user_achievements (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'è®°å½•ID',
  user_id VARCHAR(50) NOT NULL COMMENT 'ç”¨æˆ·ID',
  achievement_id VARCHAR(50) NOT NULL COMMENT 'æˆå°±ID',
  progress INT DEFAULT 0 COMMENT 'å½“å‰è¿›åº¦',
  unlocked BOOLEAN DEFAULT FALSE COMMENT 'æ˜¯å¦å·²è§£é”',
  unlocked_at TIMESTAMP NULL COMMENT 'è§£é”æ—¶é—´',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (achievement_id) REFERENCES achievements(id),
  
  UNIQUE KEY uk_user_achievement (user_id, achievement_id),
  INDEX idx_user (user_id),
  INDEX idx_unlocked (unlocked)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='ç”¨æˆ·æˆå°±è¡¨';
```

---

### 4.3 çŸ¥è¯†åº“ç›¸å…³ï¼ˆ3å¼ è¡¨ï¼‰

#### knowledge_articles - çŸ¥è¯†åº“æ–‡ç« è¡¨

```sql
CREATE TABLE knowledge_articles (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'æ–‡ç« ID',
  category VARCHAR(50) NOT NULL COMMENT 'åˆ†ç±»',
  title VARCHAR(255) NOT NULL COMMENT 'æ ‡é¢˜',
  summary TEXT COMMENT 'æ‘˜è¦',
  content LONGTEXT COMMENT 'å†…å®¹(Markdown)',
  content_html LONGTEXT COMMENT 'å†…å®¹(HTML)',
  cover_image VARCHAR(255) COMMENT 'å°é¢å›¾',
  images JSON COMMENT 'é…å›¾',
  video_url VARCHAR(255) COMMENT 'è§†é¢‘URL',
  author_id VARCHAR(50) NOT NULL COMMENT 'ä½œè€…ID',
  type ENUM('article', 'video') DEFAULT 'article' COMMENT 'ç±»å‹',
  difficulty ENUM('å…¥é—¨', 'è¿›é˜¶', 'é«˜çº§') DEFAULT 'å…¥é—¨' COMMENT 'éš¾åº¦',
  read_time INT DEFAULT 5 COMMENT 'é¢„è®¡é˜…è¯»æ—¶é•¿(åˆ†é’Ÿ)',
  views INT DEFAULT 0 COMMENT 'æµè§ˆé‡',
  likes INT DEFAULT 0 COMMENT 'ç‚¹èµæ•°',
  tags JSON COMMENT 'æ ‡ç­¾',
  related_articles JSON COMMENT 'ç›¸å…³æ–‡ç« ID',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  
  FOREIGN KEY (author_id) REFERENCES users(id),
  
  INDEX idx_category (category),
  INDEX idx_type (type),
  INDEX idx_views (views),
  INDEX idx_likes (likes),
  FULLTEXT INDEX ft_title_content (title, content)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='çŸ¥è¯†åº“æ–‡ç« è¡¨';
```

#### knowledge_questions - çŸ¥è¯†åº“é—®ç­”è¡¨

```sql
CREATE TABLE knowledge_questions (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'é—®é¢˜ID',
  question VARCHAR(500) NOT NULL COMMENT 'é—®é¢˜å†…å®¹',
  asker_id VARCHAR(50) NOT NULL COMMENT 'æé—®è€…ID',
  answer_count INT DEFAULT 0 COMMENT 'å›ç­”æ•°',
  views INT DEFAULT 0 COMMENT 'æµè§ˆé‡',
  best_answer_id INT NULL COMMENT 'æœ€ä½³ç­”æ¡ˆID',
  tags JSON COMMENT 'æ ‡ç­¾',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  
  FOREIGN KEY (asker_id) REFERENCES users(id),
  
  INDEX idx_asker (asker_id),
  INDEX idx_views (views),
  FULLTEXT INDEX ft_question (question)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='çŸ¥è¯†åº“é—®ç­”è¡¨';
```

#### knowledge_answers - çŸ¥è¯†åº“å›ç­”è¡¨

```sql
CREATE TABLE knowledge_answers (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'å›ç­”ID',
  question_id INT NOT NULL COMMENT 'é—®é¢˜ID',
  author_id VARCHAR(50) NOT NULL COMMENT 'å›ç­”è€…ID',
  content TEXT NOT NULL COMMENT 'å›ç­”å†…å®¹',
  likes INT DEFAULT 0 COMMENT 'ç‚¹èµæ•°',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  
  FOREIGN KEY (question_id) REFERENCES knowledge_questions(id) ON DELETE CASCADE,
  FOREIGN KEY (author_id) REFERENCES users(id),
  
  INDEX idx_question (question_id),
  INDEX idx_author (author_id),
  INDEX idx_likes (likes)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='çŸ¥è¯†åº“å›ç­”è¡¨';
```

---

### 4.4 è®¢é‡‘æ‰˜ç®¡ç›¸å…³ï¼ˆ1å¼ è¡¨ï¼‰

#### escrow_records - è®¢é‡‘æ‰˜ç®¡è®°å½•è¡¨

```sql
-- PostgreSQLè¯­æ³•ï¼šåˆ›å»ºENUMç±»å‹
CREATE TYPE deposit_status_enum AS ENUM ('escrow', 'settled', 'refunded');

CREATE TABLE escrow_records (
  id SERIAL PRIMARY KEY,
  order_id VARCHAR(50) NOT NULL UNIQUE,
  deposit_status deposit_status_enum DEFAULT 'escrow',
  escrow_amount DECIMAL(10, 2) NOT NULL,
  escrow_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  settle_time TIMESTAMP,
  refund_time TIMESTAMP,
  refund_reason VARCHAR(255),
  
  FOREIGN KEY (order_id) REFERENCES orders(id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_escrow_records_order ON escrow_records(order_id);
CREATE INDEX idx_escrow_records_status ON escrow_records(deposit_status);
CREATE INDEX idx_escrow_records_time ON escrow_records(escrow_time);

-- æ·»åŠ æ³¨é‡Š
COMMENT ON TABLE escrow_records IS 'è®¢é‡‘æ‰˜ç®¡è®°å½•è¡¨';
COMMENT ON COLUMN escrow_records.deposit_status IS 'çŠ¶æ€ï¼šæ‰˜ç®¡ä¸­/å·²ç»“ç®—/å·²é€€æ¬¾';
COMMENT ON COLUMN escrow_records.escrow_amount IS 'æ‰˜ç®¡é‡‘é¢';
```

> **æç¤º**ï¼šæ‰€æœ‰å…¶ä»–è¡¨çš„SQLè¯­æ³•å¯æŒ‰ç…§ç›¸åŒæ–¹å¼è½¬æ¢ï¼š
> - `INT AUTO_INCREMENT` â†’ `SERIAL`
> - `ENUM(...)` â†’ `CREATE TYPE ... AS ENUM(...)`
> - `COMMENT` â†’ `COMMENT ON TABLE/COLUMN`
> - `ON UPDATE CURRENT_TIMESTAMP` â†’ è§¦å‘å™¨å®ç°

---

### 4.5 å›¢é•¿ä¿è¯é‡‘ç›¸å…³ï¼ˆ2å¼ è¡¨ï¼‰

#### leader_deposits - å›¢é•¿ä¿è¯é‡‘è¡¨

```sql
CREATE TABLE leader_deposits (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'è®°å½•ID',
  leader_id VARCHAR(50) NOT NULL UNIQUE COMMENT 'å›¢é•¿ID',
  deposit_amount DECIMAL(10, 2) DEFAULT 5000.00 COMMENT 'ä¿è¯é‡‘é‡‘é¢',
  deposit_status ENUM('active', 'frozen', 'refunded') DEFAULT 'active' COMMENT 'çŠ¶æ€',
  deposit_interest DECIMAL(10, 2) DEFAULT 0 COMMENT 'ç´¯è®¡åˆ©æ¯',
  withdrawable_interest DECIMAL(10, 2) DEFAULT 0 COMMENT 'å¯æå–åˆ©æ¯',
  required_amount DECIMAL(10, 2) DEFAULT 5000.00 COMMENT 'æ‰€éœ€ä¿è¯é‡‘',
  deposit_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'ç¼´çº³æ—¶é—´',
  update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
  
  FOREIGN KEY (leader_id) REFERENCES users(id),
  
  INDEX idx_leader (leader_id),
  INDEX idx_status (deposit_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='å›¢é•¿ä¿è¯é‡‘è¡¨';
```

#### deposit_penalty_records - ä¿è¯é‡‘èµ”ä»˜è®°å½•è¡¨

```sql
CREATE TABLE deposit_penalty_records (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'è®°å½•ID',
  leader_id VARCHAR(50) NOT NULL COMMENT 'å›¢é•¿ID',
  order_id VARCHAR(50) NOT NULL COMMENT 'è®¢å•ID',
  reason VARCHAR(255) NOT NULL COMMENT 'èµ”ä»˜åŸå› ',
  amount DECIMAL(10, 2) NOT NULL COMMENT 'èµ”ä»˜é‡‘é¢',
  create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  
  FOREIGN KEY (leader_id) REFERENCES users(id),
  FOREIGN KEY (order_id) REFERENCES orders(id),
  
  INDEX idx_leader (leader_id),
  INDEX idx_order (order_id),
  INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='ä¿è¯é‡‘èµ”ä»˜è®°å½•è¡¨';
```

---

### 4.6 è‡ªåŠ¨å‚¬æ¬¾ç›¸å…³ï¼ˆ1å¼ è¡¨ï¼‰

#### payment_reminders - å‚¬æ¬¾è®°å½•è¡¨

```sql
CREATE TABLE payment_reminders (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'è®°å½•ID',
  order_id VARCHAR(50) NOT NULL COMMENT 'è®¢å•ID',
  reminder_type ENUM('first', 'second', 'third', 'warning', 'final') NOT NULL COMMENT 'å‚¬æ¬¾ç±»å‹',
  channel ENUM('sms', 'wechat', 'app_push', 'phone') NOT NULL COMMENT 'é€šçŸ¥æ¸ é“',
  message TEXT COMMENT 'å‚¬æ¬¾å†…å®¹',
  sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'å‘é€æ—¶é—´',
  status ENUM('sent', 'failed', 'delivered') DEFAULT 'sent' COMMENT 'å‘é€çŠ¶æ€',
  
  FOREIGN KEY (order_id) REFERENCES orders(id),
  
  INDEX idx_order (order_id),
  INDEX idx_sent_at (sent_at),
  INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='å‚¬æ¬¾è®°å½•è¡¨';
```

---

### 4.7 é»‘åå•ç›¸å…³ï¼ˆ1å¼ è¡¨ï¼‰

#### blacklist - ç”¨æˆ·é»‘åå•è¡¨

```sql
CREATE TABLE blacklist (
  id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'è®°å½•ID',
  user_id VARCHAR(50) NOT NULL UNIQUE COMMENT 'ç”¨æˆ·ID',
  reason VARCHAR(255) NOT NULL COMMENT 'åŸå› ',
  order_id VARCHAR(50) COMMENT 'å…³è”è®¢å•ID',
  owed_amount DECIMAL(10, 2) COMMENT 'æ¬ æ¬¾é‡‘é¢',
  added_by VARCHAR(50) NOT NULL COMMENT 'æ·»åŠ äººID',
  added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'æ·»åŠ æ—¶é—´',
  can_remove_after TIMESTAMP NULL COMMENT 'å¯è§£é™¤æ—¶é—´',
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (order_id) REFERENCES orders(id),
  FOREIGN KEY (added_by) REFERENCES users(id),
  
  INDEX idx_user (user_id),
  INDEX idx_added_at (added_at),
  INDEX idx_can_remove (can_remove_after)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='ç”¨æˆ·é»‘åå•è¡¨';
```

---

### 4.8 æ•°æ®åº“ERå…³ç³»å›¾

```mermaid
erDiagram
    users ||--o{ dolls : "æ‹¥æœ‰"
    users ||--o{ user_achievements : "è·å¾—"
    users ||--o{ knowledge_articles : "åˆ›ä½œ"
    users ||--o{ knowledge_questions : "æé—®"
    users ||--o{ knowledge_answers : "å›ç­”"
    users ||--o{ leader_deposits : "ç¼´çº³"
    users ||--o{ blacklist : "è¢«åˆ—å…¥"
    
    dolls ||--o{ maintenance_records : "æœ‰"
    dolls }o--|| orders : "æ¥è‡ª"
    
    achievements ||--o{ user_achievements : "åŒ…å«"
    
    knowledge_questions ||--o{ knowledge_answers : "æœ‰"
    knowledge_questions }o--|| knowledge_answers : "æœ€ä½³ç­”æ¡ˆ"
    
    orders ||--o| escrow_records : "æ‰˜ç®¡"
    orders ||--o{ payment_reminders : "å‚¬æ¬¾"
    orders ||--o{ deposit_penalty_records : "èµ”ä»˜"
    orders ||--o{ blacklist : "å¯¼è‡´"
    
    leader_deposits ||--o{ deposit_penalty_records : "æ‰£é™¤"
    
    users {
        varchar id PK
        varchar name
        varchar role
        int credit_score
        decimal balance
    }
    
    dolls {
        varchar id PK
        varchar user_id FK
        varchar name
        varchar brand
        varchar size
        date birthday
    }
    
    maintenance_records {
        varchar id PK
        varchar doll_id FK
        date date
        varchar type
        text note
    }
    
    achievements {
        varchar id PK
        varchar category
        varchar name
        int required
        int rarity
    }
    
    user_achievements {
        int id PK
        varchar user_id FK
        varchar achievement_id FK
        int progress
        boolean unlocked
    }
    
    escrow_records {
        int id PK
        varchar order_id FK
        enum deposit_status
        decimal escrow_amount
        timestamp escrow_time
    }
    
    leader_deposits {
        int id PK
        varchar leader_id FK
        decimal deposit_amount
        enum deposit_status
        decimal deposit_interest
    }
    
    payment_reminders {
        int id PK
        varchar order_id FK
        enum reminder_type
        enum channel
        timestamp sent_at
    }
    
    blacklist {
        int id PK
        varchar user_id FK
        varchar reason
        decimal owed_amount
        timestamp added_at
    }
```

---

## äº”ã€æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

### 5.1 å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç†

#### æ·»åŠ å¨ƒå¨ƒé€»è¾‘

```rust
// src/handlers/dolls.rs
use axum::{extract::State, http::StatusCode, Json};
use sqlx::PgPool;
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::NaiveDate;

#[derive(Deserialize)]
pub struct CreateDollRequest {
    name: String,
    brand: Option<String>,
    size: Option<String>,
    skin_color: Option<String>,
    birthday: Option<NaiveDate>,
    weight: Option<i32>,
    height: Option<i32>,
    eye_color: Option<String>,
    wig_color: Option<String>,
    makeup: Option<String>,
    order_id: Option<String>,
    images: Option<Vec<String>>,
    notes: Option<String>,
}

#[derive(Serialize)]
pub struct DollResponse {
    id: String,
    user_id: String,
    name: String,
    // ... å…¶ä»–å­—æ®µ
}

pub async fn create_doll(
    State(pool): State<PgPool>,
    user_id: String,  // ä»JWTä¸­é—´ä»¶æå–
    Json(payload): Json<CreateDollRequest>,
) -> Result<Json<DollResponse>, StatusCode> {
    // 1. éªŒè¯æ•°æ®å®Œæ•´æ€§
    if payload.name.is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // 2. ç”Ÿæˆå¨ƒå¨ƒID
    let doll_id = Uuid::new_v4().to_string();
    
    // 3. å¤„ç†å›¾ç‰‡ä¸Šä¼ ï¼ˆå¦‚æœæœ‰ï¼‰
    let images_json = match payload.images {
        Some(images) => {
            // ä¸Šä¼ åˆ°OSSå¹¶è·å–URL
            let uploaded_urls = upload_images_to_oss(images).await?;
            serde_json::to_value(uploaded_urls).unwrap()
        }
        None => serde_json::json!([]),
    };
    
    // 4. æ’å…¥æ•°æ®åº“
    let doll = sqlx::query_as!(
        Doll,
        r#"
        INSERT INTO dolls (
            id, user_id, name, brand, size, skin_color, birthday,
            weight, height, eye_color, wig_color, makeup, images,
            order_id, notes, create_time, update_time
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW(), NOW()
        )
        RETURNING *
        "#,
        doll_id,
        user_id,
        payload.name,
        payload.brand,
        payload.size,
        payload.skin_color,
        payload.birthday,
        payload.weight,
        payload.height,
        payload.eye_color,
        payload.wig_color,
        payload.makeup,
        images_json,
        payload.order_id,
        payload.notes
    )
    .fetch_one(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 5. å¦‚æœæœ‰å…³è”è®¢å•ï¼Œæ›´æ–°è®¢å•çš„doll_idå­—æ®µ
    if let Some(order_id) = payload.order_id {
        sqlx::query!(
            "UPDATE orders SET doll_id = $1 WHERE id = $2",
            doll_id,
            order_id
        )
        .execute(&pool)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    }
    
    // 6. æ£€æŸ¥æˆå°±ï¼ˆé¦–æ¬¡æ·»åŠ å¨ƒå¨ƒï¼‰
    check_achievement(&pool, &user_id, "add_first_doll", None).await;
    
    Ok(Json(DollResponse {
        id: doll.id,
        user_id: doll.user_id,
        name: doll.name,
        // ... å…¶ä»–å­—æ®µ
    }))
}

async fn upload_images_to_oss(images: Vec<String>) -> Result<Vec<String>, StatusCode> {
    // OSSä¸Šä¼ é€»è¾‘
    // è¿”å›ä¸Šä¼ åçš„URLåˆ—è¡¨
    Ok(images)
}
```

#### è®¡ç®—å…»å¨ƒå¤©æ•°

```rust
// src/utils/doll.rs
use chrono::{NaiveDate, Utc};

pub fn calculate_days_owned(birthday: NaiveDate) -> i64 {
    let now = Utc::now().naive_utc().date();
    (now - birthday).num_days()
}
```

---

### 5.2 æˆå°±ç³»ç»Ÿ

#### äº‹ä»¶è§¦å‘æˆå°±æ£€æŸ¥

```rust
// src/services/achievement.rs
use sqlx::PgPool;
use std::collections::HashMap;
use serde_json::Value;

// äº‹ä»¶ç±»å‹æ˜ å°„
lazy_static! {
    static ref ACHIEVEMENT_EVENTS: HashMap<&'static str, Vec<&'static str>> = {
        let mut m = HashMap::new();
        m.insert("order_complete", vec!["newbie_badge", "shopaholic", "rich"]);
        m.insert("real_name_verify", vec!["real_name"]);
        m.insert("post_create", vec!["social_butterfly"]);
        m.insert("receive_like", vec!["popular"]);
        m.insert("transfer_order", vec!["transfer_master"]);
        m
    };
}

pub async fn check_achievement(
    pool: &PgPool,
    user_id: &str,
    event_type: &str,
    event_data: Option<Value>,
) -> Result<(), sqlx::Error> {
    // 1. è·å–è¯¥äº‹ä»¶å¯èƒ½è§¦å‘çš„æˆå°±åˆ—è¡¨
    let achievement_ids = ACHIEVEMENT_EVENTS
        .get(event_type)
        .cloned()
        .unwrap_or_default();
    
    // 2. éå†æ£€æŸ¥æ¯ä¸ªæˆå°±
    for achievement_id in achievement_ids {
        // 3. æŸ¥è¯¢ç”¨æˆ·å½“å‰è¿›åº¦
        let user_achievement = sqlx::query!(
            r#"
            SELECT * FROM user_achievements
            WHERE user_id = $1 AND achievement_id = $2
            "#,
            user_id,
            achievement_id
        )
        .fetch_optional(pool)
        .await?;
        
        // 4. å¦‚æœä¸å­˜åœ¨ï¼Œåˆ›å»ºè®°å½•
        let mut user_achievement = if let Some(ua) = user_achievement {
            ua
        } else {
            sqlx::query!(
                r#"
                INSERT INTO user_achievements (user_id, achievement_id, progress, unlocked)
                VALUES ($1, $2, 0, false)
                RETURNING *
                "#,
                user_id,
                achievement_id
            )
            .fetch_one(pool)
            .await?
        };
        
        // 5. å¦‚æœå·²è§£é”ï¼Œè·³è¿‡
        if user_achievement.unlocked {
            continue;
        }
        
        // 6. æŸ¥è¯¢æˆå°±ä¿¡æ¯
        let achievement = sqlx::query!(
            "SELECT * FROM achievements WHERE id = $1",
            achievement_id
        )
        .fetch_one(pool)
        .await?;
        
        // 7. è®¡ç®—æ–°è¿›åº¦
        let new_progress = calculate_progress(pool, user_id, &achievement, event_data.as_ref())
            .await?;
        
        // 8. æ›´æ–°è¿›åº¦
        sqlx::query!(
            r#"
            UPDATE user_achievements
            SET progress = $1, update_time = NOW()
            WHERE user_id = $2 AND achievement_id = $3
            "#,
            new_progress,
            user_id,
            achievement_id
        )
        .execute(pool)
        .await?;
        
        // 9. æ£€æŸ¥æ˜¯å¦è¾¾åˆ°è§£é”æ¡ä»¶
        if new_progress >= achievement.required {
            unlock_achievement(pool, user_id, &achievement).await?;
        }
    }
    
    Ok(())
}

async fn unlock_achievement(
    pool: &PgPool,
    user_id: &str,
    achievement: &Achievement,
) -> Result<(), sqlx::Error> {
    // 1. æ ‡è®°ä¸ºå·²è§£é”
    sqlx::query!(
        r#"
        UPDATE user_achievements
        SET unlocked = true, unlocked_at = NOW()
        WHERE user_id = $1 AND achievement_id = $2
        "#,
        user_id,
        achievement.id
    )
    .execute(pool)
    .await?;
    
    // 2. å‘æ”¾å¥–åŠ±
    let mut rewards = Vec::new();
    
    // ä¼˜æƒ åˆ¸
    if achievement.reward_coupon > 0 {
        let coupon = create_coupon(pool, user_id, achievement.reward_coupon).await?;
        rewards.push(json!({"type": "coupon", "value": coupon}));
    }
    
    // ä¿¡ç”¨åˆ†
    if achievement.reward_credit > 0 {
        sqlx::query!(
            r#"
            UPDATE users
            SET credit_score = credit_score + $1
            WHERE id = $2
            "#,
            achievement.reward_credit as i32,
            user_id
        )
        .execute(pool)
        .await?;
        rewards.push(json!({"type": "credit", "value": achievement.reward_credit}));
    }
    
    // 3. æ¨é€é€šçŸ¥
    send_notification(user_id, &json!({
        "type": "achievement_unlocked",
        "title": format!("æ­å–œè§£é”æˆå°±ï¼š{}", achievement.name),
        "content": format!("è·å¾—å¥–åŠ±ï¼š{}", serde_json::to_string(&rewards).unwrap()),
        "related_id": achievement.id
    }))
    .await;
    
    // 4. æ›´æ–°å…¨å¹³å°è§£é”äººæ•°
    sqlx::query!(
        "UPDATE achievements SET total_unlocked = total_unlocked + 1 WHERE id = $1",
        achievement.id
    )
    .execute(pool)
    .await?;
    
    Ok(())
}

async fn calculate_progress(
    pool: &PgPool,
    user_id: &str,
    achievement: &Achievement,
    event_data: Option<&Value>,
) -> Result<i32, sqlx::Error> {
    // æ ¹æ®æˆå°±ç±»å‹è®¡ç®—è¿›åº¦
    match achievement.id.as_str() {
        "newbie_badge" | "shopaholic" => {
            let count: i64 = sqlx::query_scalar!(
                "SELECT COUNT(*) FROM orders WHERE user_id = $1",
                user_id
            )
            .fetch_one(pool)
            .await?;
            Ok(count as i32)
        }
        "rich" => {
            let total: Option<f64> = sqlx::query_scalar!(
                "SELECT SUM(price) FROM orders WHERE user_id = $1",
                user_id
            )
            .fetch_one(pool)
            .await?;
            Ok(total.unwrap_or(0.0) as i32)
        }
        _ => Ok(1),
    }
}
```

---

### 5.3 è®¢é‡‘æ‰˜ç®¡

#### å®šæ—¶ä»»åŠ¡ï¼šæ£€æŸ¥æ‰˜ç®¡çŠ¶æ€

```rust
// src/tasks/escrow_check.rs
use sqlx::PgPool;
use chrono::Utc;
use tracing::info;

pub async fn check_escrow_status(pool: PgPool) -> Result<(), sqlx::Error> {
    info!("å¼€å§‹æ£€æŸ¥è®¢é‡‘æ‰˜ç®¡çŠ¶æ€...");
    
    // 1. æŸ¥è¯¢æ‰€æœ‰æ‰˜ç®¡ä¸­çš„è®¢å•
    let escrow_records = sqlx::query_as!(
        EscrowRecord,
        "SELECT * FROM escrow_records WHERE deposit_status = 'escrow'"
    )
    .fetch_all(&pool)
    .await?;
    
    for record in escrow_records {
        let order = sqlx::query_as!(
            Order,
            "SELECT * FROM orders WHERE id = $1",
            record.order_id
        )
        .fetch_one(&pool)
        .await?;
        
        let group_buy = sqlx::query_as!(
            GroupBuy,
            "SELECT * FROM group_buys WHERE id = $1",
            order.group_buy_id
        )
        .fetch_one(&pool)
        .await?;
        
        // 2. æ£€æŸ¥æ˜¯å¦æˆªå›¢æˆåŠŸ
        if group_buy.status == "åˆ¶ä½œä¸­" || group_buy.status == "è¡¥æ¬¾ä¸­" {
            settle_escrow(&pool, &record).await?;
            continue;
        }
        
        // 3. æ£€æŸ¥æ˜¯å¦æµå›¢
        if group_buy.status == "å·²å–æ¶ˆ" {
            refund_escrow(&pool, &record, "å›¢è´­å–æ¶ˆ").await?;
            continue;
        }
        
        // 4. æ£€æŸ¥æ˜¯å¦è¶…æœŸ
        let now = Utc::now().naive_utc();
        if let Some(deadline) = group_buy.deadline {
            if now > deadline && group_buy.status == "å¾é›†ä¸­" {
                refund_escrow(&pool, &record, "è¶…æœŸæœªæˆªå›¢").await?;
            }
        }
    }
    
    info!("è®¢é‡‘æ‰˜ç®¡çŠ¶æ€æ£€æŸ¥å®Œæˆ");
    Ok(())
}

async fn settle_escrow(pool: &PgPool, record: &EscrowRecord) -> Result<(), sqlx::Error> {
    // 1. æ›´æ–°æ‰˜ç®¡è®°å½•çŠ¶æ€
    sqlx::query!(
        r#"
        UPDATE escrow_records
        SET deposit_status = 'settled', settle_time = NOW()
        WHERE id = $1
        "#,
        record.id
    )
    .execute(pool)
    .await?;
    
    // 2. æŸ¥è¯¢è®¢å•å’Œå›¢è´­ä¿¡æ¯
    let order = sqlx::query_as!(
        Order,
        "SELECT * FROM orders WHERE id = $1",
        record.order_id
    )
    .fetch_one(pool)
    .await?;
    
    let group_buy = sqlx::query_as!(
        GroupBuy,
        "SELECT * FROM group_buys WHERE id = $1",
        order.group_buy_id
    )
    .fetch_one(pool)
    .await?;
    
    // 3. å°†é‡‘é¢è½¬ç»™å›¢é•¿
    sqlx::query!(
        r#"
        UPDATE users
        SET balance = balance + $1
        WHERE id = $2
        "#,
        record.escrow_amount,
        group_buy.leader_id
    )
    .execute(pool)
    .await?;
    
    // 4. è®°å½•äº¤æ˜“æµæ°´
    sqlx::query!(
        r#"
        INSERT INTO transactions (type, from_user_id, to_user_id, amount, order_id)
        VALUES ('escrow_settle', 'platform', $1, $2, $3)
        "#,
        group_buy.leader_id,
        record.escrow_amount,
        record.order_id
    )
    .execute(pool)
    .await?;
    
    // 5. é€šçŸ¥å›¢é•¿
    send_notification(
        &group_buy.leader_id,
        &json!({
            "type": "escrow_settled",
            "title": "è®¢é‡‘å·²ç»“ç®—",
            "content": format!("è®¢å•{}çš„è®¢é‡‘{}å…ƒå·²åˆ°è´¦", record.order_id, record.escrow_amount)
        }),
    )
    .await;
    
    Ok(())
}

async fn refund_escrow(
    pool: &PgPool,
    record: &EscrowRecord,
    reason: &str,
) -> Result<(), sqlx::Error> {
    // 1. æ›´æ–°æ‰˜ç®¡è®°å½•çŠ¶æ€
    sqlx::query!(
        r#"
        UPDATE escrow_records
        SET deposit_status = 'refunded', refund_time = NOW(), refund_reason = $1
        WHERE id = $2
        "#,
        reason,
        record.id
    )
    .execute(pool)
    .await?;
    
    // 2. æŸ¥è¯¢è®¢å•ä¿¡æ¯
    let order = sqlx::query_as!(
        Order,
        "SELECT * FROM orders WHERE id = $1",
        record.order_id
    )
    .fetch_one(pool)
    .await?;
    
    // 3. å°†é‡‘é¢é€€å›ç”¨æˆ·
    sqlx::query!(
        r#"
        UPDATE users
        SET balance = balance + $1
        WHERE id = $2
        "#,
        record.escrow_amount,
        order.user_id
    )
    .execute(pool)
    .await?;
    
    // 4. è®°å½•äº¤æ˜“æµæ°´
    sqlx::query!(
        r#"
        INSERT INTO transactions (type, from_user_id, to_user_id, amount, order_id, reason)
        VALUES ('escrow_refund', 'platform', $1, $2, $3, $4)
        "#,
        order.user_id,
        record.escrow_amount,
        record.order_id,
        reason
    )
    .execute(pool)
    .await?;
    
    // 5. é€šçŸ¥ç”¨æˆ·
    send_notification(
        &order.user_id,
        &json!({
            "type": "escrow_refunded",
            "title": "è®¢é‡‘å·²é€€æ¬¾",
            "content": format!("è®¢å•{}çš„è®¢é‡‘{}å…ƒå·²é€€å›ï¼ŒåŸå› ï¼š{}", record.order_id, record.escrow_amount, reason)
        }),
    )
    .await;
    
    Ok(())
}

// main.rs æˆ– tasks.rs ä¸­é…ç½®å®šæ—¶ä»»åŠ¡
use tokio_cron_scheduler::{Job, JobScheduler};

pub async fn setup_escrow_check_task(pool: PgPool) -> Result<(), Box<dyn std::error::Error>> {
    let mut sched = JobScheduler::new().await?;
    
    sched
        .add(
            Job::new_async("0 2 * * *", move |_uuid, _l| {
                let pool = pool.clone();
                Box::pin(async move {
                    if let Err(e) = check_escrow_status(pool).await {
                        eprintln!("è®¢é‡‘æ‰˜ç®¡æ£€æŸ¥å¤±è´¥: {}", e);
                    }
                })
            })?
        )
        .await?;
    
    sched.start().await?;
    Ok(())
}
```

---

### 5.4 è‡ªåŠ¨å‚¬æ¬¾

#### å®šæ—¶ä»»åŠ¡ï¼šè‡ªåŠ¨å‚¬æ¬¾

```rust
// src/tasks/payment_reminder.rs
use sqlx::PgPool;
use chrono::{Utc, NaiveDateTime, Duration};
use tracing::info;

pub async fn send_payment_reminders(pool: PgPool) -> Result<(), sqlx::Error> {
    info!("å¼€å§‹è‡ªåŠ¨å‚¬æ¬¾æ£€æŸ¥...");
    
    // 1. æŸ¥è¯¢æ‰€æœ‰å¾…è¡¥æ¬¾çš„è®¢å•
    let orders = sqlx::query_as!(
        Order,
        "SELECT * FROM orders WHERE status = 'wait_final' AND final_notified_at IS NOT NULL"
    )
    .fetch_all(&pool)
    .await?;
    
    for order in orders {
        // 2. è®¡ç®—è·ç¦»é€šçŸ¥æ—¶é—´çš„å¤©æ•°
        let notified_at = order.final_notified_at.unwrap();
        let now = Utc::now().naive_utc();
        let days_since = (now - notified_at).num_days();
        
        // 3. æ£€æŸ¥å‚¬æ¬¾è®°å½•ï¼Œé¿å…é‡å¤å‘é€
        let today_start = now.date().and_hms(0, 0, 0);
        let reminder_type = get_reminder_type(days_since);
        
        let existing = sqlx::query!(
            r#"
            SELECT COUNT(*) as count FROM payment_reminders
            WHERE order_id = $1
            AND reminder_type = $2
            AND sent_at >= $3
            "#,
            order.id,
            reminder_type,
            today_start
        )
        .fetch_one(&pool)
        .await?;
        
        if existing.count.unwrap_or(0) > 0 {
            continue; // ä»Šå¤©å·²å‘é€è¿‡
        }
        
        // 4. æ ¹æ®å¤©æ•°æ‰§è¡Œä¸åŒæ“ä½œ
        match days_since {
            3 => {
                send_reminder(&pool, &order, "first", "sms").await?;
            }
            7 => {
                send_reminder(&pool, &order, "second", "sms").await?;
                send_reminder(&pool, &order, "second", "wechat").await?;
            }
            15 => {
                send_reminder(&pool, &order, "third", "sms").await?;
                send_reminder(&pool, &order, "third", "wechat").await?;
                send_reminder(&pool, &order, "third", "app_push").await?;
            }
            25 => {
                send_reminder(&pool, &order, "warning", "sms").await?;
                send_reminder(&pool, &order, "warning", "wechat").await?;
                send_reminder(&pool, &order, "warning", "app_push").await?;
                // æ ‡è®°ä¸ºè·‘å•é¢„è­¦
                sqlx::query!(
                    "UPDATE orders SET payment_warning = true WHERE id = $1",
                    order.id
                )
                .execute(&pool)
                .await?;
            }
            d if d >= 30 => {
                send_reminder(&pool, &order, "final", "sms").await?;
                // åŠ å…¥é»‘åå•
                add_to_blacklist(&pool, &order.user_id, &order.id, order.final_payment).await?;
            }
            _ => {}
        }
    }
    
    info!("è‡ªåŠ¨å‚¬æ¬¾æ£€æŸ¥å®Œæˆ");
    Ok(())
}

async fn send_reminder(
    pool: &PgPool,
    order: &Order,
    reminder_type: &str,
    channel: &str,
) -> Result<(), sqlx::Error> {
    // 1. è·å–ç”¨æˆ·ä¿¡æ¯
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        order.user_id
    )
    .fetch_one(pool)
    .await?;
    
    // 2. ç”Ÿæˆå‚¬æ¬¾æ¶ˆæ¯
    let message = generate_reminder_message(order, reminder_type);
    
    // 3. å‘é€é€šçŸ¥
    let status = match send_notification_by_channel(&user, channel, &message).await {
        Ok(_) => "sent",
        Err(e) => {
            tracing::error!("å‘é€å‚¬æ¬¾å¤±è´¥: {}", e);
            "failed"
        }
    };
    
    // 4. è®°å½•å‚¬æ¬¾è®°å½•
    sqlx::query!(
        r#"
        INSERT INTO payment_reminders (order_id, reminder_type, channel, message, status, sent_at)
        VALUES ($1, $2, $3, $4, $5, NOW())
        "#,
        order.id,
        reminder_type,
        channel,
        message,
        status
    )
    .execute(pool)
    .await?;
    
    Ok(())
}

fn generate_reminder_message(order: &Order, reminder_type: &str) -> String {
    match reminder_type {
        "first" => format!(
            "ã€BJDå›¢è´­ã€‘äº²ï¼Œæ‚¨çš„è®¢å•{}éœ€è¦è¡¥é½å°¾æ¬¾{}å…ƒï¼Œè¯·åœ¨30å¤©å†…å®Œæˆæ”¯ä»˜ã€‚",
            order.id, order.final_payment
        ),
        "second" => format!(
            "ã€BJDå›¢è´­ã€‘æ¸©é¦¨æç¤ºï¼šè®¢å•{}å°¾æ¬¾{}å…ƒå·²é€¾æœŸ7å¤©ï¼Œè¯·å°½å¿«æ”¯ä»˜ã€‚",
            order.id, order.final_payment
        ),
        "third" => format!(
            "ã€BJDå›¢è´­ã€‘é‡è¦æé†’ï¼šè®¢å•{}å°¾æ¬¾{}å…ƒå·²é€¾æœŸ15å¤©ï¼Œè¶…è¿‡30å¤©å°†æ— æ³•å‚ä¸å¹³å°å›¢è´­ã€‚",
            order.id, order.final_payment
        ),
        "warning" => format!(
            "ã€BJDå›¢è´­ã€‘æœ€åè­¦å‘Šï¼šè®¢å•{}å°¾æ¬¾{}å…ƒå·²é€¾æœŸ25å¤©ï¼Œè¶…è¿‡30å¤©å°†åŠ å…¥é»‘åå•ï¼Œå½±å“ä¿¡ç”¨ï¼",
            order.id, order.final_payment
        ),
        "final" => format!(
            "ã€BJDå›¢è´­ã€‘æ‚¨çš„è®¢å•{}å·²è¶…æœŸ30å¤©æœªæ”¯ä»˜ï¼Œå·²åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‚ä¸ä»»ä½•å›¢è´­ã€‚å¦‚éœ€è§£é™¤è¯·è¡¥é½æ¬ æ¬¾ã€‚",
            order.id
        ),
        _ => String::new(),
    }
}

fn get_reminder_type(days: i64) -> &'static str {
    match days {
        3 => "first",
        7 => "second",
        15 => "third",
        25 => "warning",
        d if d >= 30 => "final",
        _ => "",
    }
}
```

---

### 5.5 é»‘åå•ç®¡ç†

```rust
// src/services/blacklist.rs
use sqlx::PgPool;
use chrono::{Utc, Duration};
use anyhow::{Result, anyhow};

pub async fn add_to_blacklist(
    pool: &PgPool,
    user_id: &str,
    order_id: &str,
    owed_amount: f64,
) -> Result<(), sqlx::Error> {
    // 1. æ£€æŸ¥æ˜¯å¦å·²åœ¨é»‘åå•
    let existing = sqlx::query!(
        "SELECT id FROM blacklist WHERE user_id = $1",
        user_id
    )
    .fetch_optional(pool)
    .await?;
    
    if existing.is_some() {
        return Ok(()); // å·²åœ¨é»‘åå•
    }
    
    // 2. æ·»åŠ åˆ°é»‘åå•
    let can_remove_after = Utc::now().naive_utc() + Duration::days(30);
    sqlx::query!(
        r#"
        INSERT INTO blacklist (user_id, reason, order_id, owed_amount, added_by, can_remove_after)
        VALUES ($1, $2, $3, $4, 'system', $5)
        "#,
        user_id,
        "è®¢å•è¶…æœŸ30å¤©æœªæ”¯ä»˜å°¾æ¬¾",
        order_id,
        owed_amount,
        can_remove_after
    )
    .execute(pool)
    .await?;
    
    // 3. é™ä½ä¿¡ç”¨åˆ†
    sqlx::query!(
        r#"
        UPDATE users
        SET credit_score = credit_score - 20
        WHERE id = $1
        "#,
        user_id
    )
    .execute(pool)
    .await?;
    
    // 4. å‘é€é€šçŸ¥
    send_notification(
        user_id,
        &json!({
            "type": "blacklist_added",
            "title": "è´¦å·å·²è¢«é™åˆ¶",
            "content": format!("ç”±äºè®¢å•{}è¶…æœŸ30å¤©æœªæ”¯ä»˜å°¾æ¬¾ï¼Œæ‚¨çš„è´¦å·å·²åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‚ä¸å›¢è´­ã€‚è¯·è¡¥é½æ¬ æ¬¾{}å…ƒåç”³è¯·è§£é™¤ã€‚", order_id, owed_amount)
        }),
    )
    .await;
    
    Ok(())
}

pub async fn remove_from_blacklist(pool: &PgPool, user_id: &str) -> Result<(), anyhow::Error> {
    // 1. æŸ¥è¯¢é»‘åå•è®°å½•
    let record = sqlx::query_as!(
        BlacklistRecord,
        "SELECT * FROM blacklist WHERE user_id = $1",
        user_id
    )
    .fetch_optional(pool)
    .await?;
    
    let record = record.ok_or_else(|| anyhow!("ç”¨æˆ·ä¸åœ¨é»‘åå•ä¸­"))?;
    
    // 2. æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ¬ æ¬¾
    if let Some(owed_amount) = record.owed_amount {
        if owed_amount > 0.0 {
            if let Some(order_id) = record.order_id {
                let order = sqlx::query_as!(
                    Order,
                    "SELECT * FROM orders WHERE id = $1",
                    order_id
                )
                .fetch_one(pool)
                .await?;
                
                if order.status == "wait_final" {
                    return Err(anyhow!("è¯·å…ˆè¡¥é½æ¬ æ¬¾"));
                }
            }
        }
    }
    
    // 3. ç§»é™¤é»‘åå•
    sqlx::query!("DELETE FROM blacklist WHERE user_id = $1", user_id)
        .execute(pool)
        .await?;
    
    // 4. æ¢å¤éƒ¨åˆ†ä¿¡ç”¨åˆ†
    sqlx::query!(
        r#"
        UPDATE users
        SET credit_score = credit_score + 10
        WHERE id = $1
        "#,
        user_id
    )
    .execute(pool)
    .await?;
    
    // 5. å‘é€é€šçŸ¥
    send_notification(
        user_id,
        &json!({
            "type": "blacklist_removed",
            "title": "é»‘åå•å·²è§£é™¤",
            "content": "æ‚¨çš„è´¦å·å·²æ¢å¤æ­£å¸¸ï¼Œå¯ä»¥ç»§ç»­å‚ä¸å›¢è´­ã€‚è¯·æŒ‰æ—¶æ”¯ä»˜æ¬¾é¡¹ï¼Œç»´æŠ¤è‰¯å¥½ä¿¡ç”¨ã€‚"
        }),
    )
    .await;
    
    Ok(())
}
```

---

## å…­ã€æŠ€æœ¯è¦ç‚¹

### 6.1 æ€§èƒ½ä¼˜åŒ–

#### æ•°æ®åº“ç´¢å¼•ç­–ç•¥

```sql
-- é«˜é¢‘æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
ALTER TABLE dolls ADD INDEX idx_user_create (user_id, create_time);
ALTER TABLE user_achievements ADD INDEX idx_user_unlocked (user_id, unlocked);
ALTER TABLE knowledge_articles ADD INDEX idx_category_views (category, views);

-- è”åˆç´¢å¼•ä¼˜åŒ–å¤šå­—æ®µæŸ¥è¯¢
ALTER TABLE escrow_records ADD INDEX idx_status_time (deposit_status, escrow_time);
ALTER TABLE payment_reminders ADD INDEX idx_order_type (order_id, reminder_type);
```

#### ç¼“å­˜ç­–ç•¥

```rust
// src/services/cache.rs
use redis::Client;
use serde::{Serialize, Deserialize};
use std::time::Duration;

pub struct CacheService {
    client: Client,
}

impl CacheService {
    pub fn new(redis_url: &str) -> Result<Self, redis::RedisError> {
        let client = Client::open(redis_url)?;
        Ok(Self { client })
    }
    
    // Redisç¼“å­˜çƒ­é—¨æ–‡ç« 
    pub async fn get_article<T: for<'de> Deserialize<'de>>(
        &self,
        article_id: &str,
    ) -> Result<Option<T>, redis::RedisError> {
        let mut conn = self.client.get_async_connection().await?;
        
        // 1. å…ˆæŸ¥ç¼“å­˜
        let cached: Option<String> = redis::cmd("GET")
            .arg(format!("article:{}", article_id))
            .query_async(&mut conn)
            .await?;
        
        if let Some(cached_str) = cached {
            if let Ok(article) = serde_json::from_str::<T>(&cached_str) {
                return Ok(Some(article));
            }
        }
        
        Ok(None)
    }
    
    pub async fn set_article<T: Serialize>(
        &self,
        article_id: &str,
        article: &T,
        ttl: Duration,
    ) -> Result<(), redis::RedisError> {
        let mut conn = self.client.get_async_connection().await?;
        let json_str = serde_json::to_string(article).unwrap();
        
        // å†™å…¥ç¼“å­˜ï¼ˆ1å°æ—¶è¿‡æœŸï¼‰
        redis::cmd("SETEX")
            .arg(format!("article:{}", article_id))
            .arg(ttl.as_secs())
            .arg(&json_str)
            .query_async(&mut conn)
            .await?;
        
        Ok(())
    }
    
    // æˆå°±åˆ—è¡¨ç¼“å­˜
    pub async fn get_achievements<T: for<'de> Deserialize<'de>>(
        &self,
    ) -> Result<Option<T>, redis::RedisError> {
        let mut conn = self.client.get_async_connection().await?;
        
        let cached: Option<String> = redis::cmd("GET")
            .arg("achievements:all")
            .query_async(&mut conn)
            .await?;
        
        if let Some(cached_str) = cached {
            if let Ok(achievements) = serde_json::from_str::<T>(&cached_str) {
                return Ok(Some(achievements));
            }
        }
        
        Ok(None)
    }
    
    pub async fn set_achievements<T: Serialize>(
        &self,
        achievements: &T,
        ttl: Duration,
    ) -> Result<(), redis::RedisError> {
        let mut conn = self.client.get_async_connection().await?;
        let json_str = serde_json::to_string(achievements).unwrap();
        
        redis::cmd("SETEX")
            .arg("achievements:all")
            .arg(ttl.as_secs())
            .arg(&json_str)
            .query_async(&mut conn)
            .await?;
        
        Ok(())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn get_article_with_cache(
    pool: &PgPool,
    cache: &CacheService,
    article_id: i32,
) -> Result<Article, sqlx::Error> {
    // å…ˆæŸ¥ç¼“å­˜
    if let Ok(Some(article)) = cache.get_article::<Article>(&article_id.to_string()).await {
        return Ok(article);
    }
    
    // æŸ¥æ•°æ®åº“
    let article = sqlx::query_as!(
        Article,
        "SELECT * FROM knowledge_articles WHERE id = $1",
        article_id
    )
    .fetch_one(pool)
    .await?;
    
    // å†™å…¥ç¼“å­˜
    let _ = cache
        .set_article(&article_id.to_string(), &article, Duration::from_secs(3600))
        .await;
    
    Ok(article)
}
```

---

### 6.2 å®‰å…¨æªæ–½

#### APIé‰´æƒ

```rust
// src/middleware/auth.rs
use axum::{
    extract::{Request, State},
    http::{HeaderMap, StatusCode},
    middleware::Next,
    response::Response,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub user_id: String,
    pub role: String,
    pub exp: usize,
}

pub async fn auth_middleware(
    State(secret): State<String>,
    headers: HeaderMap,
    mut req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // 1. æå–Token
    let token = headers
        .get("authorization")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.strip_prefix("Bearer "))
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // 2. éªŒè¯Token
    let decoding_key = DecodingKey::from_secret(secret.as_ref());
    let validation = Validation::new(Algorithm::HS256);
    
    let claims = decode::<Claims>(token, &decoding_key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    // 3. å°†ç”¨æˆ·ä¿¡æ¯æ”¾å…¥è¯·æ±‚æ‰©å±•
    req.extensions_mut().insert(claims.claims.clone());
    
    Ok(next.run(req).await)
}

// ä»è¯·æ±‚æ‰©å±•ä¸­æå–ç”¨æˆ·ä¿¡æ¯
pub fn extract_user(req: &Request) -> Option<&Claims> {
    req.extensions().get::<Claims>()
}

// æƒé™éªŒè¯è¾…åŠ©å‡½æ•°
pub fn require_role(claims: &Claims, allowed_roles: &[&str]) -> Result<(), StatusCode> {
    if allowed_roles.contains(&claims.role.as_str()) {
        Ok(())
    } else {
        Err(StatusCode::FORBIDDEN)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
use axum::{extract::Request, http::StatusCode, response::Json};

pub async fn get_dolls_handler(
    State(pool): State<PgPool>,
    req: Request,
) -> Result<Json<Vec<Doll>>, StatusCode> {
    let claims = extract_user(&req).ok_or(StatusCode::UNAUTHORIZED)?;
    
    // æŸ¥è¯¢ç”¨æˆ·çš„å¨ƒå¨ƒåˆ—è¡¨
    let dolls = sqlx::query_as!(
        Doll,
        "SELECT * FROM dolls WHERE user_id = $1",
        claims.user_id
    )
    .fetch_all(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(dolls))
}

pub async fn pay_deposit_handler(
    State(pool): State<PgPool>,
    req: Request,
) -> Result<Json<DepositResponse>, StatusCode> {
    let claims = extract_user(&req).ok_or(StatusCode::UNAUTHORIZED)?;
    
    // éªŒè¯æƒé™ï¼ˆä»…å›¢é•¿ï¼‰
    require_role(claims, &["leader"])?;
    
    // ä¸šåŠ¡é€»è¾‘...
    Ok(Json(DepositResponse { .. }))
}

// main.rs ä¸­é…ç½®è·¯ç”±
use axum::{
    middleware,
    routing::{get, post},
    Router,
};

let app = Router::new()
    .route("/api/v1/dolls", get(get_dolls_handler))
    .route("/api/v1/deposits/pay", post(pay_deposit_handler))
    .layer(middleware::from_fn_with_state(jwt_secret, auth_middleware));
```

#### æ•°æ®éªŒè¯

```rust
// ä½¿ç”¨validatorè¿›è¡Œå‚æ•°éªŒè¯
use validator::{Validate, ValidationError};
use serde::Deserialize;

#[derive(Debug, Deserialize, Validate)]
pub struct CreateDollRequest {
    #[validate(length(min = 1, max = 100))]
    pub name: String,
    
    #[validate(length(max = 100))]
    pub brand: Option<String>,
    
    #[validate(custom = "validate_size")]
    pub size: Option<String>,
    
    pub birthday: Option<chrono::NaiveDate>,
    
    #[validate(range(min = 1, max = 10000))]
    pub weight: Option<i32>,
    
    #[validate(range(min = 1, max = 200))]
    pub height: Option<i32>,
}

fn validate_size(size: &str) -> Result<(), ValidationError> {
    let valid_sizes = vec!["å”", "1/3", "1/4", "1/6", "1/8", "1/12"];
    if valid_sizes.contains(&size) {
        Ok(())
    } else {
        Err(ValidationError::new("invalid_size"))
    }
}

// Handlerä¸­ä½¿ç”¨éªŒè¯
pub async fn create_doll_handler(
    State(pool): State<PgPool>,
    req: Request,
    Json(payload): Json<CreateDollRequest>,
) -> Result<Json<DollResponse>, StatusCode> {
    // éªŒè¯å‚æ•°
    payload.validate()
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    
    let claims = extract_user(&req).ok_or(StatusCode::UNAUTHORIZED)?;
    
    // ä¸šåŠ¡é€»è¾‘...
    Ok(Json(DollResponse { .. }))
}
```

---

### 6.3 å®šæ—¶ä»»åŠ¡ç®¡ç†

```rust
// src/tasks/mod.rs
use tokio_cron_scheduler::{Job, JobScheduler};
use sqlx::PgPool;
use tracing::info;

pub struct CronManager {
    scheduler: JobScheduler,
    pool: PgPool,
}

impl CronManager {
    pub fn new(pool: PgPool) -> Self {
        Self {
            scheduler: JobScheduler::new().expect("Failed to create scheduler"),
            pool,
        }
    }
    
    // è®¢é‡‘æ‰˜ç®¡æ£€æŸ¥ï¼ˆæ¯å¤©å‡Œæ™¨2ç‚¹ï¼‰
    pub async fn start_escrow_check(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let pool = self.pool.clone();
        self.scheduler
            .add(
                Job::new_async("0 2 * * *", move |_uuid, _l| {
                    let pool = pool.clone();
                    Box::pin(async move {
                        info!("[å®šæ—¶ä»»åŠ¡] å¼€å§‹æ£€æŸ¥è®¢é‡‘æ‰˜ç®¡...");
                        if let Err(e) = super::escrow_check::check_escrow_status(pool).await {
                            tracing::error!("è®¢é‡‘æ‰˜ç®¡æ£€æŸ¥å¤±è´¥: {}", e);
                        }
                        info!("[å®šæ—¶ä»»åŠ¡] è®¢é‡‘æ‰˜ç®¡æ£€æŸ¥å®Œæˆ");
                    })
                })?
            )
            .await?;
        Ok(())
    }
    
    // è‡ªåŠ¨å‚¬æ¬¾ï¼ˆæ¯å¤©æ—©ä¸Š9ç‚¹ï¼‰
    pub async fn start_payment_reminder(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let pool = self.pool.clone();
        self.scheduler
            .add(
                Job::new_async("0 9 * * *", move |_uuid, _l| {
                    let pool = pool.clone();
                    Box::pin(async move {
                        info!("[å®šæ—¶ä»»åŠ¡] å¼€å§‹è‡ªåŠ¨å‚¬æ¬¾...");
                        if let Err(e) = super::payment_reminder::send_payment_reminders(pool).await {
                            tracing::error!("è‡ªåŠ¨å‚¬æ¬¾å¤±è´¥: {}", e);
                        }
                        info!("[å®šæ—¶ä»»åŠ¡] è‡ªåŠ¨å‚¬æ¬¾å®Œæˆ");
                    })
                })?
            )
            .await?;
        Ok(())
    }
    
    // ä¿è¯é‡‘åˆ©æ¯è®¡ç®—ï¼ˆæ¯æœˆ1å·å‡Œæ™¨3ç‚¹ï¼‰
    pub async fn start_interest_calculation(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let pool = self.pool.clone();
        self.scheduler
            .add(
                Job::new_async("0 3 1 * *", move |_uuid, _l| {
                    let pool = pool.clone();
                    Box::pin(async move {
                        info!("[å®šæ—¶ä»»åŠ¡] å¼€å§‹è®¡ç®—ä¿è¯é‡‘åˆ©æ¯...");
                        if let Err(e) = super::deposit_interest::calculate_deposit_interest(pool).await {
                            tracing::error!("ä¿è¯é‡‘åˆ©æ¯è®¡ç®—å¤±è´¥: {}", e);
                        }
                        info!("[å®šæ—¶ä»»åŠ¡] åˆ©æ¯è®¡ç®—å®Œæˆ");
                    })
                })?
            )
            .await?;
        Ok(())
    }
    
    // å¯åŠ¨æ‰€æœ‰ä»»åŠ¡
    pub async fn start_all(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        self.start_escrow_check().await?;
        self.start_payment_reminder().await?;
        self.start_interest_calculation().await?;
        
        self.scheduler.start().await?;
        info!("[å®šæ—¶ä»»åŠ¡] å·²å¯åŠ¨æ‰€æœ‰å®šæ—¶ä»»åŠ¡");
        Ok(())
    }
    
    // åœæ­¢æ‰€æœ‰ä»»åŠ¡
    pub async fn stop_all(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        self.scheduler.shutdown().await?;
        info!("[å®šæ—¶ä»»åŠ¡] æ‰€æœ‰å®šæ—¶ä»»åŠ¡å·²åœæ­¢");
        Ok(())
    }
}

// main.rs ä¸­ä½¿ç”¨
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // è¿æ¥æ•°æ®åº“
    let database_url = std::env::var("DATABASE_URL")?;
    let pool = PgPool::connect(&database_url).await?;
    
    // åˆ›å»ºå¹¶å¯åŠ¨å®šæ—¶ä»»åŠ¡ç®¡ç†å™¨
    let mut cron_manager = CronManager::new(pool.clone());
    cron_manager.start_all().await?;
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    let app = create_app(pool).await?;
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    
    info!("æœåŠ¡å™¨å¯åŠ¨åœ¨ http://0.0.0.0:3000");
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

---

## ä¸ƒã€å¼€å‘è®¡åˆ’

### 7.1 å¼€å‘ä¼˜å…ˆçº§

#### ç¬¬ä¸€é˜¶æ®µï¼ˆWeek 1-2ï¼‰- åŸºç¡€åŠŸèƒ½

- [ ] **å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç†**ï¼ˆ7ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] CRUDæ¥å£å®ç°
  - [ ] å›¾ç‰‡ä¸Šä¼ OSS
  - [ ] ä¿å…»è®°å½•ç®¡ç†
  - [ ] å•å…ƒæµ‹è¯•

- [ ] **æˆå°±ç³»ç»Ÿ**ï¼ˆ3ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] æˆå°±æŸ¥è¯¢æ¥å£
  - [ ] è§£é”è§¦å‘æœºåˆ¶
  - [ ] å¥–åŠ±å‘æ”¾é€»è¾‘
  - [ ] å•å…ƒæµ‹è¯•

- [ ] **BJDçŸ¥è¯†åº“**ï¼ˆ5ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] æ–‡ç« /é—®ç­”æ¥å£
  - [ ] å…¨æ–‡æœç´¢é…ç½®
  - [ ] ç‚¹èµåŠŸèƒ½
  - [ ] å•å…ƒæµ‹è¯•

---

#### ç¬¬äºŒé˜¶æ®µï¼ˆWeek 3-4ï¼‰- äº¤æ˜“ä¿éšœ

- [ ] **è®¢é‡‘æ‰˜ç®¡**ï¼ˆ3ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] æ‰˜ç®¡æ”¯ä»˜æ¥å£
  - [ ] å®šæ—¶ä»»åŠ¡å®ç°
  - [ ] è‡ªåŠ¨ç»“ç®—/é€€æ¬¾
  - [ ] å•å…ƒæµ‹è¯•

- [ ] **å›¢é•¿ä¿è¯é‡‘**ï¼ˆ3ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] ä¿è¯é‡‘ç®¡ç†æ¥å£
  - [ ] åˆ©æ¯è®¡ç®—å®šæ—¶ä»»åŠ¡
  - [ ] èµ”ä»˜é€»è¾‘
  - [ ] å•å…ƒæµ‹è¯•

---

#### ç¬¬ä¸‰é˜¶æ®µï¼ˆWeek 5-6ï¼‰- é£æ§ç³»ç»Ÿ

- [ ] **è‡ªåŠ¨å‚¬æ¬¾**ï¼ˆ2ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] å‚¬æ¬¾è®°å½•æ¥å£
  - [ ] å®šæ—¶ä»»åŠ¡å®ç°
  - [ ] å¤šæ¸ é“é€šçŸ¥
  - [ ] å•å…ƒæµ‹è¯•

- [ ] **é»‘åå•ç®¡ç†**ï¼ˆ3ä¸ªæ¥å£ï¼‰
  - [ ] æ•°æ®è¡¨åˆ›å»º
  - [ ] é»‘åå•CRUDæ¥å£
  - [ ] è‡ªåŠ¨åŠ å…¥/è§£é™¤é€»è¾‘
  - [ ] æƒé™æ§åˆ¶
  - [ ] å•å…ƒæµ‹è¯•

---

### 7.2 å›¢é˜Ÿåˆ†å·¥å»ºè®®

| æ¨¡å— | å»ºè®®äººæ•° | æŠ€èƒ½è¦æ±‚ |
|------|---------|---------|
| å¨ƒå¨ƒæ¡£æ¡ˆç®¡ç† | 1äºº | Node.js + æ–‡ä»¶ä¸Šä¼  |
| æˆå°±ç³»ç»Ÿ | 1äºº | Node.js + äº‹ä»¶ç³»ç»Ÿ |
| BJDçŸ¥è¯†åº“ | 1äºº | Node.js + å…¨æ–‡æœç´¢ |
| è®¢é‡‘æ‰˜ç®¡ | 1äºº | Node.js + å®šæ—¶ä»»åŠ¡ |
| å›¢é•¿ä¿è¯é‡‘ | 1äºº | Node.js + é‡‘èè®¡ç®— |
| è‡ªåŠ¨å‚¬æ¬¾ | 1äºº | Node.js + æ¶ˆæ¯æ¨é€ |
| é»‘åå•ç®¡ç† | 1äºº | Node.js + æƒé™æ§åˆ¶ |

**æ€»è®¡**ï¼š6-7äººï¼Œé¢„è®¡6å‘¨å®Œæˆ

---

### 7.3 æµ‹è¯•è®¡åˆ’

#### å•å…ƒæµ‹è¯•

```rust
// tests/dolls_test.rs
use axum::http::{StatusCode, header::HeaderValue};
use sqlx::PgPool;
use crate::handlers::dolls::create_doll;
use crate::middleware::auth::Claims;

#[sqlx::test]
async fn test_create_doll_success(pool: PgPool) {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    let user_id = "test_user_123".to_string();
    let claims = Claims {
        user_id: user_id.clone(),
        role: "user".to_string(),
        exp: (chrono::Utc::now() + chrono::Duration::hours(1)).timestamp() as usize,
    };
    
    let request = CreateDollRequest {
        name: "æµ‹è¯•å¨ƒå¨ƒ".to_string(),
        brand: Some("Test Brand".to_string()),
        size: Some("1/4".to_string()),
        skin_color: None,
        birthday: None,
        weight: None,
        height: None,
        eye_color: None,
        wig_color: None,
        makeup: None,
        order_id: None,
        images: None,
        notes: None,
    };
    
    // æ‰§è¡Œæµ‹è¯•
    let response = create_doll(
        State(pool),
        claims.user_id,
        Json(request)
    )
    .await;
    
    // éªŒè¯ç»“æœ
    assert!(response.is_ok());
    let doll_response = response.unwrap();
    assert_eq!(doll_response.0.name, "æµ‹è¯•å¨ƒå¨ƒ");
    assert!(!doll_response.0.id.is_empty());
}

#[sqlx::test]
async fn test_create_doll_missing_name(pool: PgPool) {
    let user_id = "test_user_123".to_string();
    let claims = Claims {
        user_id: user_id.clone(),
        role: "user".to_string(),
        exp: (chrono::Utc::now() + chrono::Duration::hours(1)).timestamp() as usize,
    };
    
    let request = CreateDollRequest {
        name: String::new(), // ç©ºåç§°
        brand: Some("Test Brand".to_string()),
        size: None,
        skin_color: None,
        birthday: None,
        weight: None,
        height: None,
        eye_color: None,
        wig_color: None,
        makeup: None,
        order_id: None,
        images: None,
        notes: None,
    };
    
    let response = create_doll(
        State(pool),
        claims.user_id,
        Json(request)
    )
    .await;
    
    assert!(response.is_err());
    assert_eq!(response.unwrap_err(), StatusCode::BAD_REQUEST);
}

// é›†æˆæµ‹è¯•ç¤ºä¾‹
#[tokio::test]
async fn test_doll_api_integration() {
    // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    let app = create_test_app().await;
    
    // è·å–è®¤è¯Token
    let token = get_test_token().await;
    
    // åˆ›å»ºå¨ƒå¨ƒ
    let client = reqwest::Client::new();
    let response = client
        .post("http://localhost:3000/api/v1/dolls")
        .header("Authorization", format!("Bearer {}", token))
        .json(&serde_json::json!({
            "name": "æµ‹è¯•å¨ƒå¨ƒ",
            "brand": "Test Brand",
            "size": "1/4"
        }))
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
    
    let doll: DollResponse = response.json().await.unwrap();
    assert_eq!(doll.name, "æµ‹è¯•å¨ƒå¨ƒ");
}
```

#### é›†æˆæµ‹è¯•

- [ ] å¨ƒå¨ƒåˆ›å»º â†’ å…³è”è®¢å•æŸ¥è¯¢
- [ ] æˆå°±è§£é” â†’ å¥–åŠ±å‘æ”¾ â†’ é€šçŸ¥æ¨é€
- [ ] è®¢é‡‘æ”¯ä»˜ â†’ æ‰˜ç®¡ â†’ è‡ªåŠ¨ç»“ç®—
- [ ] å‚¬æ¬¾ â†’ é»‘åå• â†’ æƒé™é™åˆ¶

---

### 7.4 éƒ¨ç½²æ£€æŸ¥æ¸…å•

#### æ•°æ®åº“

- [ ] åˆ›å»ºæ‰€æœ‰æ•°æ®è¡¨
- [ ] é…ç½®ç´¢å¼•
- [ ] åˆå§‹åŒ–æˆå°±æ•°æ®
- [ ] æ•°æ®åº“å¤‡ä»½ç­–ç•¥

#### æœåŠ¡

- [ ] APIæœåŠ¡éƒ¨ç½²
- [ ] å®šæ—¶ä»»åŠ¡é…ç½®
- [ ] Redisç¼“å­˜é…ç½®
- [ ] OSSå­˜å‚¨é…ç½®

#### ç›‘æ§

- [ ] æ¥å£æ€§èƒ½ç›‘æ§
- [ ] å®šæ—¶ä»»åŠ¡æ—¥å¿—
- [ ] é”™è¯¯å‘Šè­¦
- [ ] æ•°æ®åº“æ…¢æŸ¥è¯¢ç›‘æ§

---

## ğŸ“ é™„å½•

### A. å®Œæ•´æ¥å£æ¸…å•ï¼ˆExcelæ ¼å¼ï¼‰

| æ¨¡å— | æ–¹æ³• | è·¯å¾„ | è¯´æ˜ | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ |
|------|------|------|------|--------|---------|
| å¨ƒå¨ƒæ¡£æ¡ˆ | GET | /api/v1/dolls | è·å–åˆ—è¡¨ | P0 | 4h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | GET | /api/v1/dolls/{id} | è·å–è¯¦æƒ… | P0 | 2h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | POST | /api/v1/dolls | æ·»åŠ å¨ƒå¨ƒ | P0 | 6h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | PUT | /api/v1/dolls/{id} | æ›´æ–°ä¿¡æ¯ | P0 | 4h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | DELETE | /api/v1/dolls/{id} | åˆ é™¤å¨ƒå¨ƒ | P0 | 2h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | POST | /api/v1/dolls/{id}/maintenance | æ·»åŠ ä¿å…»è®°å½• | P0 | 3h |
| å¨ƒå¨ƒæ¡£æ¡ˆ | POST | /api/v1/dolls/{id}/id-card | ç”Ÿæˆèº«ä»½è¯ | P0 | 4h |
| æˆå°±ç³»ç»Ÿ | GET | /api/v1/achievements | è·å–åˆ—è¡¨ | P0 | 4h |
| æˆå°±ç³»ç»Ÿ | POST | /api/v1/achievements/check | æ£€æŸ¥è§£é” | P0 | 8h |
| æˆå°±ç³»ç»Ÿ | POST | /api/v1/achievements/{id}/claim | é¢†å–å¥–åŠ± | P0 | 4h |
| çŸ¥è¯†åº“ | GET | /api/v1/knowledge/articles | æ–‡ç« åˆ—è¡¨ | P0 | 4h |
| çŸ¥è¯†åº“ | GET | /api/v1/knowledge/articles/{id} | æ–‡ç« è¯¦æƒ… | P0 | 2h |
| çŸ¥è¯†åº“ | GET | /api/v1/knowledge/questions | é—®ç­”åˆ—è¡¨ | P0 | 3h |
| çŸ¥è¯†åº“ | GET | /api/v1/knowledge/search | æœç´¢ | P0 | 6h |
| çŸ¥è¯†åº“ | POST | /api/v1/knowledge/{type}/{id}/like | ç‚¹èµ | P0 | 2h |
| è®¢é‡‘æ‰˜ç®¡ | POST | /api/v1/orders/{id}/deposit-escrow | æ‰˜ç®¡æ”¯ä»˜ | P0 | 6h |
| è®¢é‡‘æ‰˜ç®¡ | GET | /api/v1/orders/{id}/escrow-status | æŸ¥è¯¢çŠ¶æ€ | P0 | 2h |
| è®¢é‡‘æ‰˜ç®¡ | POST | /api/v1/orders/{id}/refund | ç”³è¯·é€€æ¬¾ | P0 | 4h |
| ä¿è¯é‡‘ | GET | /api/v1/deposits/leader/{id} | æŸ¥è¯¢ä¿è¯é‡‘ | P0 | 3h |
| ä¿è¯é‡‘ | POST | /api/v1/deposits/pay | ç¼´çº³ä¿è¯é‡‘ | P0 | 5h |
| ä¿è¯é‡‘ | POST | /api/v1/deposits/withdraw-interest | æå–åˆ©æ¯ | P0 | 4h |
| å‚¬æ¬¾ | GET | /api/v1/orders/{id}/reminders | å‚¬æ¬¾è®°å½• | P0 | 3h |
| å‚¬æ¬¾ | POST | /api/v1/orders/{id}/send-reminder | æ‰‹åŠ¨å‚¬æ¬¾ | P0 | 3h |
| é»‘åå• | GET | /api/v1/blacklist | æŸ¥è¯¢é»‘åå• | P0 | 3h |
| é»‘å• | POST | /api/v1/blacklist | æ·»åŠ é»‘åå• | P0 | 4h |
| é»‘åå• | DELETE | /api/v1/blacklist/{userId} | è§£é™¤é»‘åå• | P0 | 3h |

**æ€»è®¡å·¥æ—¶**ï¼š96å°æ—¶ï¼ˆçº¦12ä¸ªå·¥ä½œæ—¥ï¼‰

---

### B. æŠ€æœ¯æ ˆå»ºè®®

**åç«¯æ¡†æ¶**ï¼š
- **Rust 1.70+** + **Axum 0.7+**
- å¼‚æ­¥è¿è¡Œæ—¶ï¼šTokio
- Webæ¡†æ¶ï¼šAxumï¼ˆåŸºäºTokioçš„é«˜æ€§èƒ½å¼‚æ­¥æ¡†æ¶ï¼‰

**æ•°æ®åº“**ï¼š
- **PostgreSQL 14+**ï¼ˆä¸»åº“ï¼Œä½¿ç”¨sqlxè¿›è¡Œå¼‚æ­¥æŸ¥è¯¢ï¼‰
- **Redis 6.0+**ï¼ˆç¼“å­˜ï¼Œä½¿ç”¨redis-rså®¢æˆ·ç«¯ï¼‰

**ORM/æ•°æ®åº“å·¥å…·**ï¼š
- **sqlx 0.7+**ï¼ˆç¼–è¯‘æ—¶SQLæ£€æŸ¥ï¼Œç±»å‹å®‰å…¨ï¼‰
- æ”¯æŒå¼‚æ­¥æŸ¥è¯¢å’Œè¿æ¥æ± 

**å­˜å‚¨**ï¼š
- é˜¿é‡Œäº‘OSS / ä¸ƒç‰›äº‘ï¼ˆå›¾ç‰‡/è§†é¢‘ï¼‰
- ä½¿ç”¨ `oss-rs` æˆ– `qiniu-rs` å®¢æˆ·ç«¯

**æ¶ˆæ¯æ¨é€**ï¼š
- çŸ­ä¿¡ï¼šé˜¿é‡Œäº‘çŸ­ä¿¡ï¼ˆä½¿ç”¨ `aliyun-openapi-rs`ï¼‰
- å¾®ä¿¡ï¼šå¾®ä¿¡æœåŠ¡å·æ¨¡æ¿æ¶ˆæ¯ï¼ˆä½¿ç”¨ `wechat-rs`ï¼‰
- Appæ¨é€ï¼šæå…‰æ¨é€/ä¸ªæ¨ï¼ˆä½¿ç”¨å¯¹åº”Rust SDKï¼‰

**å®šæ—¶ä»»åŠ¡**ï¼š
- **tokio-cron-scheduler**ï¼ˆåŸºäºTokioçš„å®šæ—¶ä»»åŠ¡åº“ï¼‰
- æˆ–ä½¿ç”¨ **deadline-rs** ç­‰åº“

**è®¤è¯å’Œæˆæƒ**ï¼š
- JWTï¼šä½¿ç”¨ `jsonwebtoken`
- å¯†ç åŠ å¯†ï¼šä½¿ç”¨ `argon2` æˆ– `bcrypt`

**æ•°æ®éªŒè¯**ï¼š
- **validator**ï¼ˆå­—æ®µéªŒè¯ï¼‰
- **serde**ï¼ˆåºåˆ—åŒ–/ååºåˆ—åŒ–ï¼‰

**æ—¥å¿—å’Œç›‘æ§**ï¼š
- **tracing** + **tracing-subscriber**ï¼ˆç»“æ„åŒ–æ—¥å¿—ï¼‰
- **tower-http**ï¼ˆä¸­é—´ä»¶å’Œæ—¥å¿—ï¼‰

**æµ‹è¯•**ï¼š
- **sqlx::test**ï¼ˆæ•°æ®åº“é›†æˆæµ‹è¯•ï¼‰
- **tokio::test**ï¼ˆå¼‚æ­¥æµ‹è¯•ï¼‰
- **mockall**ï¼ˆMockå¯¹è±¡ï¼‰

**æ–‡æ¡£**ï¼š
- **utoipa** + **utoipa-swagger-ui**ï¼ˆOpenAPI/Swaggeræ–‡æ¡£ï¼‰
- æˆ– Apifox

**æ¨èä¾èµ–æ¸…å•ï¼ˆCargo.tomlï¼‰**ï¼š
```toml
[dependencies]
# Webæ¡†æ¶
axum = "0.7"
tokio = { version = "1.35", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }

# æ•°æ®åº“
sqlx = { version = "0.7", features = ["runtime-tokio-native-tls", "postgres", "chrono", "uuid"] }

# Redis
redis = { version = "0.24", features = ["tokio-comp"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# è®¤è¯
jsonwebtoken = "9.2"
argon2 = "0.5"

# éªŒè¯
validator = { version = "0.18", features = ["derive"] }

# æ—¶é—´å¤„ç†
chrono = { version = "0.4", features = ["serde"] }

# UUID
uuid = { version = "1.6", features = ["v4", "serde"] }

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# å®šæ—¶ä»»åŠ¡
tokio-cron-scheduler = "0.9"

# é…ç½®
dotenv = "0.15"
config = "0.14"

# HTTPå®¢æˆ·ç«¯ï¼ˆç”¨äºè°ƒç”¨ç¬¬ä¸‰æ–¹APIï¼‰
reqwest = { version = "0.11", features = ["json"] }

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "1.0"

# APIæ–‡æ¡£
utoipa = { version = "4.2", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "5.11", features = ["axum"] }

[dev-dependencies]
# æµ‹è¯•
mockall = "0.12"
sqlx = { version = "0.7", features = ["runtime-tokio-native-tls", "postgres", "migrate"] }
```

---

**æ–‡æ¡£ç»“æŸ** ğŸš€

ç¥å¼€å‘é¡ºåˆ©ï¼

